--This file contains various, mostly unorganized, game logic of Carcassonne

--checks if the person pressing the control panel buttons is an admin, and that the game is not already running
function checkControlPanelPrivileges(player)
    if gameIsActive() then
        broadcastToColor(translate("MESSAGE_SETUP_GAME_ALREADY_STARTED"), player.sColor, NEUTRAL_COLOR)
        return false
    end
    local PPlayer = Player[player.sColor]
    if PPlayer ~= nil then
        if PPlayer.admin then
            return true
        else
            broadcastToColor(translate("MESSAGE_SETUP_NO_CONTROL_PANEL_PERMISSIONS"), player.sColor, ERROR_COLOR)
        end
    end
    return false
end

--checks if the person pressing the button is an admin
function checkAdminPrivileges(player)
    local PPlayer = Player[player.sColor]
    if PPlayer ~= nil then
        if PPlayer.admin then
            return true
        else
            broadcastToColor(translate("MESSAGE_NO_GAME_BUTTON_PERMISSIONS"), player, ERROR_COLOR)
        end
    end
    return false
end

--checks if the person pressing the button is the current player, a hotseat's owner, or an admin
function checkGameButtonPrivileges(player)
    local PPlayer = Player[player]
    if PPlayer ~= nil then
        if PPlayer.admin or
        (currentMiniTurn ~= nil and (player == activePlayers[currentMiniTurn] or player == getCurrentPlayerOwner())) or
        (currentMiniTurn == nil and (player == activePlayers[currentPlayer] or player == getCurrentPlayerOwner())) then
            return true
        else
            broadcastToColor(translate("MESSAGE_NO_BUTTON_PERMISSIONS"), player, ERROR_COLOR)
        end
    end
    return false
end

--this function will allow object scripts (specifically the control panels) to get control panel settings
function getControlPanelState(p)
    return controlPanelSettings[p.key]
end

--this function will allow object scripts (specifically the control panels) to set control panel settings
function setControlPanelState(p)
    controlPanelSettings[p.key] = p.value
end

function languageChanged()
    self.UI.setAttribute("AICalculationLabel", "text", translate("UI_AI_CALCULATING"))
    buttonBoard.clearButtons()
    initializeButtons()
end

--this function is called when the control of the current player is changed at the beginning of a turn
function currentPlayerControllerChanged(params)
    if turnState == 'begin turn' and activePlayers[currentPlayer] == params.currentPlayer and params.newCurrentPlayerControl == controlPanelSettings[params.currentPlayer .. 'Control'] then
        stateHandler()
    end
end

--skip the rest of the turn and move to the next player
function skipTurnButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        endTurn()
    end
end

wikiTablet = nil

function showDocsButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        if (wikiTablet) then
            destroyObject(wikiTablet)
            wikiTablet = nil
        else
            tabletParameters = {}
            tabletParameters.type = "Tablet"
            tabletParameters.position = {-20.5, 1, 22}
            tabletParameters.scale = {.9, .9, .9}
            tabletParameters.rotation = {0, 180, 0}
            tabletParameters.callback_function = function(tablet)
                tablet.Browser.url = "https://wikicarpedia.com/index.php/Main_Page"
                wikiTablet = tablet
            end
            spawnObject(tabletParameters)
        end
    end
end

function endTurn()
    for _, object in ipairs(getAllObjects()) do
        if tostring(object) == 'Card(Clone) (LuaGameObjectScript)' or table.contains(FOLLOWER_TYPES, object.getVar('figureName')) or table.contains(SPECIAL_FIGURE_TYPES, object.getVar('figureName')) then
            object.highlightOff()
            object.clearButtons()
        end
    end
    if gameIsActive() then
        --the following will detect that the game has finished and will not go to the next turn
        --local tileStack = getObjectFromGUID(tileStack_GUID)
        --if tileStack == nil and finalTile_GUID == nil then
        --    allGameMessage("The game is over. Calculate the final score by pressing the End Game button. (If this was unexpected, it could be because the tile stack was taken apart or manually stacked wrong)", NEUTRAL_COLOR)
        --else
            if lastPlacedTileX ~= nil and tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid == finalRiverTile_GUID then
                --The main tile stack can be freed up
                riverHandleFinalTile()
                if controlPanelSettings['PnDDragon'] and tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid == EXPANSION_BAGS['RiverII'].contents['RiverLakeTile'].guid then
                    --Dragon has to be played by player and placement of lake can't be automated
                elseif not controlPanelSettings['RiverMixAll'] then
                    --If the river tiles aren't already mixed up, automatically place the lake tile so it
                    --doesn't have to "waste" a player's turn (and require skipping back to that player)
                    riverAddLakeTile(lastPlacedTileX, lastPlacedTileZ, tileGrid[lastPlacedTileX][lastPlacedTileZ])
                end
            end

            --Next player's turn
            currentPlayer = currentPlayer + 1
            if currentPlayer > #activePlayers then
                currentPlayer = 1
            end

            turnState = 'begin turn' --in case skip turn was pressed, go to the beginning from every state
            return stateHandler()
        --end
    end
end

--if the current player is a hotseat player, return the owner
function getCurrentPlayerOwner()
    if currentPlayer == nil then return nil end
    local player
    if currentMiniTurn ~= nil and controlPanelSettings[activePlayers[currentMiniTurn] .. 'Control'] ~= nil then
        player = controlPanelSettings[activePlayers[currentMiniTurn] .. 'Control']
    end
    if currentMiniTurn == nil and controlPanelSettings[activePlayers[currentPlayer] .. 'Control'] ~= nil then
        player = controlPanelSettings[activePlayers[currentPlayer] .. 'Control']
    end
    return player
end

--gets the owner of this seat or hotseat
function getPlayerOwner(player)
    if player == nil then return nil end
    local owner = player
    if currentMiniTurn ~= nil and controlPanelSettings[player .. 'Control'] ~= nil then
        owner = controlPanelSettings[player .. 'Control']
    end
    if currentMiniTurn == nil and controlPanelSettings[player .. 'Control'] ~= nil then
        owner = controlPanelSettings[player .. 'Control']
    end
    return owner
end

--gets the name of the person/AI controlling this color
function getPlayerOwnerName(color)
    local owner = getPlayerOwner(color)
    if owner:sub(1,2) == 'AI' then
        return owner
    elseif Player[owner].steam_name == nil then
        return "no one"
    else
        return Player[owner].steam_name
    end
end

function initializeButtons()
    buttonBoard = getObjectFromGUID(BUTTON_BOARD_GUID)
    showMarkersButtonParam.label = translate('BUTTON_LABEL_MARKERS') .. translate(showMarkers)
    buttonBoard.createButton(showMarkersButtonParam)
    if gameIsActive() then
        endGameButtonParam.label = translate('BUTTON_LABEL_END_GAME')
        endGameButtonParam.click_function = 'endGameButton'
    elseif turnState == 'game over - finished' then
        endGameButtonParam.label = translate('BUTTON_LABEL_SCORE_SUMMARY')
        endGameButtonParam.click_function = 'printScoreSummaryButton'
    else
        endGameButtonParam.label = translate('BUTTON_LABEL_START_GAME')
        endGameButtonParam.click_function = 'startGameButton'
    end
    buttonBoard.createButton(endGameButtonParam)
    skipTurnButtonParam.label = translate('BUTTON_LABEL_SKIP_TURN')
    buttonBoard.createButton(skipTurnButtonParam)
    showDocsButtonParam.label = translate('BUTTON_LABEL_SHOW_DOCS')
    buttonBoard.createButton(showDocsButtonParam)
end

-- Activates when button is pressed
function showMarkersToggleButton(object, sPlayer)
    if checkAdminPrivileges({sColor = sPlayer}) then
        -- Toggles between different showMarker modes
        if showMarkers == 'Scoring' then showMarkers = 'Hints'
        elseif showMarkers == 'Hints' then showMarkers = 'Both'
        elseif showMarkers == 'Both' then showMarkers = 'None'
        elseif showMarkers == 'None' then showMarkers = 'Scoring'
        end
        showMarkersButtonParam.label = translate('BUTTON_LABEL_MARKERS') .. translate(showMarkers)
        buttonBoard.editButton(showMarkersButtonParam)
    end
end

--starts the game if the game has not yet started. Ends the game if the game is already running
function startGameButton(object, sPlayer)
    if checkAdminPrivileges({sColor = sPlayer}) then
        local hasStartingTiles = false
        for controlPanelSetting, settingOn in pairs(controlPanelSettings) do
            if settingOn and table.contains({'StartingTileBase', 'StartingTileRiver', 'StartingTileRiverII', 'StartingTileRiverBB5', 'StartingTileCoC', 'StartingTileWoF', 'StartingTileSchool', 'StartingTileWindRoses'}, controlPanelSetting) then
                hasStartingTiles = true
            end
        end
        local hasTileStack = false
        for controlPanelSetting, settingOn in pairs(controlPanelSettings) do
            if settingOn and table.contains({'BaseTiles','InCTiles','TnBTiles','PnDTiles','TowerTiles','AnMTiles','KnRBTiles','CultTiles','CatapultTiles','BCnBTiles','HnSTiles','WoFTiles','WoFWheelTiles','FlierTiles','FerriesTiles','GoldminesTiles'}, controlPanelSetting) then
                hasTileStack = true
            end
        end
        if not hasTileStack then
            allErrorMessage({"MESSAGE_NO_TILES"}, sPlayer)
            return
        end
        for _, player_color in ipairs(PLAYER_COLORS) do
            if controlPanelSettings[player_color .. 'Control'] ~= nil and controlPanelSettings[player_color .. 'Control']:sub(1,2) == 'AI' then
                local illegalExpansion = false
                local illegalExpansionList = ""
                for controlPanelSetting, settingOn in pairs(controlPanelSettings) do
                    if settingOn and table.contains({'StartingTileCoC', 'PnDDragon', 'TowerTowers', 'AnMAbbey', 'AnMWagon', 'WoFPlague', 'FlierFlier', 'GoldminesGold', 'Phantoms'}, controlPanelSetting) then
                        illegalExpansion = true
                        illegalExpansionList = illegalExpansionList .. controlPanelSetting .. ", "
                    end
                end
                if illegalExpansion then
                    illegalExpansionList = illegalExpansionList:sub(1, -3) --get rid of the last comma and space
                    allErrorMessage({"MESSAGE_AI_INCOMPATIBLE_EXPANSIONS", {'{s1}', illegalExpansionList}}, sPlayer)
                    return
                end
                break
            end
        end
        endGameButtonParam.label = translate('BUTTON_LABEL_END_GAME')
        endGameButtonParam.click_function = 'endGameButton'
        buttonBoard.editButton(endGameButtonParam)
        startLuaCoroutine(self, 'startGame')
    end
end

function endGameButton(object, sPlayer)
    if checkAdminPrivileges({sColor = sPlayer}) then
        endGameButtonParam.label = translate('BUTTON_LABEL_SCORE_SUMMARY')
        endGameButtonParam.click_function = 'printScoreSummaryButton'
        buttonBoard.editButton(endGameButtonParam)
      	clearArbitraryButtons(true)
        if scoring ~= true then
            turnState = 'game over - prompt moving from carcassonne'
            return stateHandler()
        end
    end
end

function initializeScoreSummary()
    for _, player_color in ipairs(activePlayers) do
        scoreSummary[player_color] = {}
        scoreSummary[player_color]['City'] = 0
        scoreSummary[player_color]['Road'] = 0
        scoreSummary[player_color]['Field'] = 0
        scoreSummary[player_color]['Cloister'] = 0
        scoreSummary[player_color]['Individual Points'] = 0
        scoreSummary[player_color]['Shared Points'] = 0
        TnBInitializeScoreSummary(scoreSummary[player_color])
        HaSInitializeScoreSummary(scoreSummary[player_color])
        PnDInitializeScoreSummary(scoreSummary[player_color])
        KnRBInitializeScoreSummary(scoreSummary[player_color])
        goldInitializeScoreSummary(scoreSummary[player_color])
        towerInitializeScoreSummary(scoreSummary[player_color])
        if pigIsEnabled() then
            scoreSummary[player_color]['Wheel'] = 0
        end
    end
end

function scorePoints(player, feature, points, individual)
    if feature == 'Abbey' or feature == 'Shrine' or feature == 'Garden' or feature == "Baba Yaga's Hut" then
        feature = 'Cloister'  --these don't really need a seperate category
    end
    if scoreSummary[player][feature] == nil then
        allErrorMessage("ERROR: " .. feature .. " is not valid. Please remove this figure.")
        return
    end
    if earnedPointsThisTile[player] == nil then earnedPointsThisTile[player] = 0 end
    earnedPointsThisTile[player] = earnedPointsThisTile[player] + points
    scoreSummary[player][feature] = scoreSummary[player][feature] + points
    if individual then
            scoreSummary[player]['Individual Points'] = scoreSummary[player]['Individual Points'] + points
            if scoreSummary[player]['Individual Points'] ~= nil then
        end
    else
        if scoreSummary[player]['Shared Points'] ~= nil then
            scoreSummary[player]['Shared Points'] = scoreSummary[player]['Shared Points'] + points
        end
    end
    local scoreCounter = getObjectFromGUID(score_counter_guids[player])
    if scoreCounter ~= nil then
        scoreCounter.Counter.setValue(scoreCounter.Counter.getValue() + points)
    else
        allErrorMessage("Error adding score to " .. figure.getVar('owner') .. "'s counter")
    end
    printScoreToNotes()
end

function printScoreToNotes()
    local scoreBoard = ""
    printedPlayers = {}
    local playerNum = 1
    local rank = 1
    local lastHighscore = 0
    while true do
        local highscore = -999
        local playerNum = nil
        local color = nil
        for playerIndex, player in ipairs(activePlayers) do
            local scoreCounter = getObjectFromGUID(score_counter_guids[player])
            if not table.contains(printedPlayers, player) and scoreCounter ~= nil then
                if scoreCounter.Counter.getValue() > highscore then
                    highscore = scoreCounter.Counter.getValue()
                    playerNum = playerIndex
                    color = player
                end
            end
        end
        if highscore > -999 then
            if highscore < lastHighscore then rank = playerNum end
            local steam_name = getPlayerOwnerName(color)
            local currentPlayerMarker = ""
            if gameIsActive() and playerNum == currentPlayer then
                currentPlayerMarker = CURRENT_PLAYER_MARKER
            end
            scoreBoard = scoreBoard .. stringToBracketedHex(color) .. currentPlayerMarker .. translate({"{n1} points - {p1}", {'{n1}', highscore}, {'{p1}', steam_name}}) .. "\n"
        else
            break
        end
        table.insert(printedPlayers, color)
        playerNum = playerNum + 1
        lastHighscore = highscore
    end
    Notes.setNotes(scoreBoard)
end

function printScoreSummaryButton(object, sPlayer)
    printedPlayers = {}
    local playerNum = 1
    local rank = 1
    local lastHighscore = 0
    while true do
        local highscore = 0
        local color = nil
        for _, player in ipairs(activePlayers) do
            local scoreCounter = getObjectFromGUID(score_counter_guids[player])
            if not table.contains(printedPlayers, player) and scoreCounter ~= nil then
                if scoreCounter.Counter.getValue() > highscore then
                    highscore = scoreCounter.Counter.getValue()
                    color = player
                end
            end
        end
        if highscore > 0 then
            if highscore < lastHighscore then rank = playerNum end
            local steam_name = getPlayerOwnerName(color)
            printToColor(translate({"#{n1} - {n2} points - {c1} - {p1}", {'{n1}', rank}, {'{n2}', highscore}, {'{c1}', color}, {'{p1}', steam_name}}), sPlayer, player_color_tints[color])
            local accountedPoints = 0
            for key, score in pairs(scoreSummary[color]) do
                local featureName = key
                if key == 'Field' then featureName = 'Farms'
                elseif key == 'Road' then featureName = 'Roads'
                elseif key == 'City' then featureName = 'Cities'
                elseif key == 'Cloister' then featureName = 'Cloisters'
                end
                printToColor("  " .. translate(featureName) .. ": " .. score, sPlayer, player_color_tints[color])
                accountedPoints = accountedPoints + score
            end
            if accountedPoints ~= highscore then
                printToColor("  unaccounted points: " .. highscore - accountedPoints, sPlayer, player_color_tints[color])
            end
        else
            break
        end
        table.insert(printedPlayers, color)
        playerNum = playerNum + 1
        lastHighscore = highscore
    end
end

-- sets the scores to 0
function clearCounters()
    --Clear all victory point counters
    for _, scoreCounter_GUID in pairs(score_counter_guids) do
        local scoreCounter = getObjectFromGUID(scoreCounter_GUID)
        if scoreCounter ~= nil then
            scoreCounter.Counter.clear()
        end
    end
end

--create a table of all features containing figures
function getActiveFigures()
    baselineFollowerCounts = {}
    baselineFigures = {}
    activeFigures = {}

    for _, player in ipairs(activePlayers) do
        baselineFollowerCounts[player] = 0
        baselineFigures[player] = {}
    end
    for _, obj in ipairs(getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()) do
        if baselineFigures[obj.getVar('owner')] ~= nil and table.contains(FOLLOWER_TYPES, obj.getVar('figureName')) or table.contains(SPECIAL_FIGURE_TYPES, obj.getVar('figureName')) then
            local xIndex, zIndex, xPosition, zPosition = getFigureTileLocation(obj)
            if tileGridOccupied(xIndex, zIndex) then
                local closestFeatureMapPosition = findClosestPosition(xIndex, zIndex, xPosition, zPosition)
                local featureNum = getFeatureNumAt(xIndex, zIndex, closestFeatureMapPosition)
                -- print(obj.getGUID() .. ": pos - " .. closestFeatureMapPosition .. " featureNum - " .. featureNum)
                if activeFigures[featureNum] == nil then
                    activeFigures[featureNum] = {}
                    activeFigures[featureNum].specialFigures = {}
                    activeFigures[featureNum].followers = {}
                end
                if table.contains(FOLLOWER_TYPES, obj.getVar('figureName')) then
                    table.insert(activeFigures[featureNum].followers, obj)
                else
                    table.insert(activeFigures[featureNum].specialFigures, obj)
                end
            elseif obj.getVar('figureName') ~= 'Follower' then
                baselineFigures[obj.getVar('owner')][obj.getVar('figureName')] = true
            else
                baselineFollowerCounts[obj.getVar('owner')] = baselineFollowerCounts[obj.getVar('owner')] + 1
            end
        end
    end
end

--create a table of all features containing neutral figures, such as sheep tokens
function getActiveNeutralFigures()
    activeNeutralFigures = {}
    HaSGetActiveSheep(activeNeutralFigures)
end

--tileConnectsToSide
-- params:
--  obj: tile 1
--  int: rotation 1 (rotation of the tile)
--  int: which side of the first tile is being checked
--  obj: tile 2
--  int: rotation 2
-- returns:
--  bool: true if they match
function tileConnectsToSide(t1, r1, n1, t2, r2)
    local t1Data = getTileDataForTile(t1)
    local t2Data = getTileDataForTile(t2)
    s1 = t1Data.sides[(3 + n1 - r1) % 4 + 1]
    s2 = t2Data.sides[(3 + n1 - r2 + TILE_180_ROTATION) % 4 + 1]
    --debugMessage(2, "s1(" .. (3 + n1 - r1) % 4 + 1 .. "): " .. s1 .. " s2(" .. (3 + n1 - r2 + TILE_180_ROTATION) % 4 + 1 .. "): " .. s2)
    if s1 == 'Abbey' or s2 == 'Abbey' then return true end

    local splits1 = string.split(s1, "/")
    if #splits1 == 1 then
        if s1 == s2 then return true else return false end
    else
        local splits2 = string.split(s2, "/")
        if #splits2 == 1 then return false end
        if splits1[1] == splits2[2] and splits1[2] == splits2[1] then return true else return false end
    end
end

--tileGridOccupied
-- params:
--  int: x grid index
--  int: z grid index
-- returns:
--  bool: true if occupied
function tileGridOccupied(x, z)
    if tileGrid[x] == nil or tileGrid[x][z] == nil then return false else return true end
end

--How a figure placed at this position should be rotated
function getPositionYawRotation(position, figureYRotation)
    if position < 5 then return (position - 1 + TILE_STANDARD_ROTATION) * 90
    elseif position < 13 then return (math.floor((position - 5) / 2) + TILE_STANDARD_ROTATION) * 90
    else return figureYRotation + (TILE_STANDARD_ROTATION * 90) end
end

--check for features that have been added to, including:
--shepherds on fields, builders in cities or on roads
function checkAddedTileSpecialFigureExtensions()
    getActiveFigures()

    for featureMapPosition=1, 12 do
        local addedFeatureNum = getFeatureNumAt(lastPlacedTileX, lastPlacedTileZ, featureMapPosition)
        if activeFigures[addedFeatureNum] ~= nil then
            if featureList[addedFeatureNum].nameOfFeature ~= 'Abbey' then --do not give give sheep/extra builder tile (CAR ref 149)
                for _, figure in ipairs(activeFigures[addedFeatureNum].specialFigures) do
                    if figure.getVar('owner') == activePlayers[currentPlayer] then
                        HaSShepherdCheckAddedTileFeature(figure, featureList[addedFeatureNum].nameOfFeature)
                        TnBBuilderCheckAddedTileFeature(figure, featureList[addedFeatureNum].nameOfFeature)
                    end
                end
            end
        end
    end
end

ANIMATION_PIG_ACCEL_DEGREES = 30
ANIMATION_PIG_ACCEL_TIME = 0.5
-- using equation d = vi t + (a t * t) / 2
ANIMATION_PIG_ACCEL = ANIMATION_PIG_ACCEL_DEGREES * 2 / (ANIMATION_PIG_ACCEL_TIME * ANIMATION_PIG_ACCEL_TIME)
-- using equation d = (vi + vf) / 2 * t
ANIMATION_PIG_MAX_VELOCITY = ANIMATION_PIG_ACCEL_DEGREES * 2 / ANIMATION_PIG_ACCEL_TIME
-- 60 degrees per space
ANIMATION_PIG_TIME_PER_SPACE = 60 / ANIMATION_PIG_MAX_VELOCITY

function checkTileForWheel()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    local newTileData = getTileDataForTile(newTile)
    local specialFeatures = newTileData.specialFeatures
    if specialFeatures ~= nil then
        for _, specialFeature in ipairs(specialFeatures) do
            if pigIsEnabled() and string.sub(specialFeature[1],1,6) == 'Wheel-' then
                local pos_moved = string.sub(specialFeature[1],7,7)
                startAnimation({type='WoFPig', start_time=os.clock(), start_position=wofPigPosition, num_positions_moved=pos_moved})
                wofPigPosition = wofPigPosition + pos_moved
                if wofPigPosition > 6 then wofPigPosition = wofPigPosition - 6 end
                Timer.create({identifier=newTile.getGUID() .. os.clock(), function_name='resolveWheel', function_owner=nil, parameters={}, delay=ANIMATION_PIG_ACCEL_TIME * 2 + (pos_moved - 1) * ANIMATION_PIG_TIME_PER_SPACE + 0.5}) --0.5 is an arbitrary delay
                return
            end
        end
    end
    return nextState('next')
end

WHEEL_POSITIONS = {'Fortune', 'Taxes', 'Famine', 'Storm', 'Inquisition', 'Plague'}

function resolveWheel()
    if controlPanelSettings['WoF' .. WHEEL_POSITIONS[wofPigPosition]] then
        getActiveFigures()
        if WHEEL_POSITIONS[wofPigPosition] == 'Fortune' then
            allGameMessage({"MESSAGE_WHEEL_FORTUNE"}, NEUTRAL_COLOR)
            allGameMessage({"MESSAGE_WHEEL_FORTUNE_SCORED", {'{p1}', getPlayerOwnerName(activePlayers[currentPlayer])}}, player_color_tints[activePlayers[currentPlayer]])
            scorePoints(activePlayers[currentPlayer], 'Wheel', 3, true)
        elseif WHEEL_POSITIONS[wofPigPosition] == 'Taxes' then
            allGameMessage({"MESSAGE_WHEEL_TAXES"}, NEUTRAL_COLOR)
            for featureNum, figures in pairs(activeFigures) do
                if featureList[featureNum].nameOfFeature == 'City' then
                    local num_pennants = 0
                    for _, specialFeature in ipairs(featureList[featureNum].specialFeatures) do
                        if specialFeature == 'Pennant' then
                            num_pennants = num_pennants + 1
                        end
                    end
                    for _, follower in ipairs(figures.followers) do
                        num_points = num_pennants
                        for _, nestedFollower in ipairs(figures.followers) do
                            if follower.getVar('owner') == nestedFollower.getVar('owner') then
                                num_points = num_points + 1
                            end
                        end
                        allGameMessage({"MESSAGE_WHEEL_EVENT_SCORED", {'{p1}', getPlayerOwnerName(follower.getVar('owner'))}, {'{n1}', num_points}, {'{s1}', translate(WHEEL_POSITIONS[wofPigPosition])}}, player_color_tints[follower.getVar('owner')])
                        scorePoints(follower.getVar('owner'), 'Wheel', num_points, true)
                    end
                end
            end
        elseif WHEEL_POSITIONS[wofPigPosition] == 'Famine' then
            allGameMessage({"MESSAGE_WHEEL_FAMINE"}, NEUTRAL_COLOR)
            for featureNum, figures in pairs(activeFigures) do
                if featureList[featureNum].nameOfFeature == 'Field' and
                    linkedFeatures['City-Field'][featureNum] ~= nil then --has at least one connected city
                    local num_cities = 0
                    for linkedFeatureNum, _ in pairs(linkedFeatures['City-Field'][featureNum]) do
                        if (featureList[linkedFeatureNum].nameOfFeature == 'City' or featureList[linkedFeatureNum].nameOfFeature == 'Carcassonne') and featureList[linkedFeatureNum].numOpenings == 0 then
                            num_cities = num_cities + 1
                        end
                    end
                    -- CAR pg 111 ref 333
                    local containsPigHerd = false
                    for _, feature in ipairs(featureList[featureNum].specialFeatures) do
                        if feature == 'Pig-herd' and not controlPanelSettings['RIIDisablePigherd'] then
                            containsPigHerd = true
                        end
                    end
                    local hasPig = {}
                    for _, figure in ipairs(figures.specialFigures) do
                        if figure.getVar('figureName') == 'Pig' then
                            hasPig[figure.getVar('owner')] = true
                        end
                    end
                    if num_cities > 0 then
                        for _, follower in ipairs(figures.followers) do
                            local scoreMultiplier = 1
                            if hasPig[follower.getVar('owner')] ~= nil then
                                scoreMultiplier = scoreMultiplier + 1
                            end
                            if containsPigHerd then
                                scoreMultiplier = scoreMultiplier + 1
                            end
                            local playerScore = num_cities * scoreMultiplier
                            allGameMessage({"MESSAGE_WHEEL_EVENT_SCORED", {'{p1}', getPlayerOwnerName(follower.getVar('owner'))}, {'{n1}', playerScore}, {'{s1}', translate(WHEEL_POSITIONS[wofPigPosition])}}, player_color_tints[follower.getVar('owner')])
                            scorePoints(follower.getVar('owner'), 'Wheel', playerScore, true)
                        end
                    end
                end
            end
        elseif WHEEL_POSITIONS[wofPigPosition] == 'Storm' then
            allGameMessage({"MESSAGE_WHEEL_STORM"}, NEUTRAL_COLOR)
            for playerColor, num_followers in pairs(baselineFollowerCounts) do
                allGameMessage({"MESSAGE_WHEEL_EVENT_SCORED", {'{p1}', getPlayerOwnerName(playerColor)}, {'{n1}', num_followers}, {'{s1}', translate(WHEEL_POSITIONS[wofPigPosition])}}, player_color_tints[playerColor])
                scorePoints(playerColor, 'Wheel', num_followers, true)
            end
        elseif WHEEL_POSITIONS[wofPigPosition] == 'Inquisition' then
            allGameMessage({"MESSAGE_WHEEL_INQUISITION"}, NEUTRAL_COLOR)
            for featureNum, figures in pairs(activeFigures) do
                if table.contains(CLOISTER_FEATURES, featureList[featureNum].nameOfFeature) then
                    for _, follower in ipairs(figures.followers) do
                        allGameMessage({"MESSAGE_WHEEL_INQUISITION_SCORED", {'{p1}', getPlayerOwnerName(follower.getVar('owner'))}, {'{n1}', 2}, {'{s1}', translate(WHEEL_POSITIONS[wofPigPosition])}}, player_color_tints[follower.getVar('owner')])
                        scorePoints(follower.getVar('owner'), 'Wheel', 2, true)
                    end
                end
            end
        else--if WHEEL_POSITIONS[wofPigPosition == 'Plague'] then
            allGameMessage({"MESSAGE_WHEEL_PLAGUE"}, NEUTRAL_COLOR)
            return nextState('plague')
        end
    else
        allGameMessage({"MESSAGE_WHEEL_EVENT_DISABLED", {'{s1}', translate(WHEEL_POSITIONS[wofPigPosition])}}, NEUTRAL_COLOR)
    end
    return nextState('crown')
end

function resolvePlague()
    getActiveFigures()
    while true do
        if currentMiniTurn == nil then
            currentMiniTurn = currentPlayer
        else
            currentMiniTurn = currentMiniTurn + 1
            if currentMiniTurn > #activePlayers then currentMiniTurn = 1 end
            if currentMiniTurn == currentPlayer then break end
        end
        local removableFigures = {}
        for featureNum, figures in pairs(activeFigures) do
            if string.sub(featureList[featureNum].nameOfFeature,1,6) ~= 'Crown-' and string.sub(featureList[featureNum].nameOfFeature,1,8) ~= 'Quarter-' then
                for _, follower in ipairs(figures.followers) do
                    if follower.getVar('owner') == activePlayers[currentMiniTurn] then
                        table.insert(removableFigures, follower)
                    end
                end
            end
        end
        if #removableFigures == 0 then
            allGameMessage({"MESSAGE_WHEEL_PLAGUE_PLAYER_SKIPPED", {'{p1}', getPlayerOwnerName(activePlayers[currentMiniTurn])}}, player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
        elseif #removableFigures == 1 then
            allGameMessage({"MESSAGE_WHEEL_PLAGUE_FOLLOWER_AUTOMATICALLY_REMOVED", {'{p1}', getPlayerOwnerName(activePlayers[currentMiniTurn])}}, player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
            table.insert(removedFigures, {guid=removableFigures[1].getGUID(), winner=false})
            removeDependentFigures(removableFigures[1])
            return returnFigures()
        else
            allGameMessage({"MESSAGE_WHEEL_PLAGUE_PROMPT", {'{p1}', getPlayerOwnerName(activePlayers[currentMiniTurn])}}, player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
            for _, follower in ipairs(removableFigures) do
                local plaguedFollowerButtonParam = {
                   index = 1, label = translate("BUTTON_LABEL_RETURN_FOLLOWER"), click_function = 'plaguedFollowerButton',
                   position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=1.0}, width = 1700, height=600, font_size = 200, function_owner = nil
                }
                createNormalizedButton(follower, plaguedFollowerButtonParam, true)
            end
            return
        end
    end
    currentMiniTurn = nil
    return nextState('next')
end

function plaguedFollowerButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        --although we later remove these buttons, there is a slight delay during the figure removal, so we remove them now
        clearArbitraryButtons()

        table.insert(removedFigures, {guid=object.getGUID(), winner=false})
        allGameMessage({"MESSAGE_WHEEL_PLAGUE_REMOVAL", {'{c1}', object.getDescription()}, {'{f1}', object.getName()}}, player_color_tints[object.getVar('owner')])
        removeDependentFigures(object)
        return returnFigures()
    end
end

--Reward points for followers on Wheel of Fortune Crown spaces when the pig lands on it
function rewardCrownSpaces()
    if controlPanelSettings['WoFCrowns'] then
        local crownFollowers = {}
        for featureNum, figures in pairs(activeFigures) do
            if featureList[featureNum].nameOfFeature == 'Crown-' .. WHEEL_POSITIONS[wofPigPosition] then
                for _, follower in ipairs(figures.followers) do
                    table.insert(crownFollowers, follower)
                end
            end
        end
        if #crownFollowers > 0 then
            local points = 6
            if #crownFollowers > 1 or table.contains({'Fortune', 'Famine', 'Inquisition'}, WHEEL_POSITIONS[wofPigPosition]) then points = 3 end
            for i, follower in ipairs(crownFollowers) do
                allGameMessage({"MESSAGE_WHEEL_CROWN_SCORED", {'{p1}', getPlayerOwnerName(follower.getVar('owner'))}, {'{n1}', points}, {'{s1}', translate(WHEEL_POSITIONS[wofPigPosition])}}, player_color_tints[follower.getVar('owner')])
                scorePoints(follower.getVar('owner'), 'Wheel', points, true)

                if showMarkers == 'Both' or showMarkers == 'Scoring' then
                    local xIndex, zIndex, xPosition, zPosition = getFigureTileLocation(follower)
                    local closestTilePosition = findClosestTilePosition(xIndex, zIndex, xPosition, zPosition)
                    getFeatureComponents(xIndex, zIndex, closestTilePosition, 2, i == 1)
                end

                table.insert(removedFigures, {guid=follower.getGUID(), winner=true})
                follower.setLock(false)
                follower.use_gravity = false
                follower.interactable = false
                --raise the follower in the air
                follower.setPositionSmooth({follower.getPosition().x, follower.getPosition().y + 2.5, follower.getPosition().z}, false, false)
            end
            if showMarkers == 'Both' or showMarkers == 'Scoring' then
                Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
            else
                returnFigures()
            end
            return
        end
    end
    return nextState('next')
end


--check for special actions to take when the latest tile has added to or finished a feature
function checkAddedTileFeatureExtensions()

    KnRBCheckFeatureInitialize()

    local tileData = getTileDataForTile(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid))
    local specialFeatures = tileData.specialFeatures
    local isAbbey = false
    if specialFeatures ~= nil then
        for _, specialFeature in ipairs(specialFeatures) do
            if specialFeature[1] == 'Abbey' then
                isAbbey = true
            end
        end
    end

    local featureVisited = {}
    for featureMapPosition=1, 12 do --roads and cities
        local featureNum
        if isAbbey then
            local connectedFeatureMapPosition, connectedX, connectedZ = getConnectingFeatureMapPosition(lastPlacedTileX, lastPlacedTileZ, featureMapPosition, TILE_STANDARD_ROTATION)
            featureNum = getFeatureNumAt(connectedX, connectedZ, connectedFeatureMapPosition)
        else
            featureNum = getFeatureNumAt(lastPlacedTileX, lastPlacedTileZ, featureMapPosition)
        end
        if featureNum ~= nil and not featureVisited[featureNum] then
            local feature = featureList[featureNum]
            if feature.numOpenings == 0 then --if the feature is complete (no openings)
                --since there is a chance of the player breaking the new city or road record twice, wait until afterwards to award the token
                KnRBCheckFeatureMap(feature)

                --unlike the above, can immediately award trade tokens
                TnBCheckFeatureMap(feature)

                statsHandleFeatureComplete(feature)
            end
            featureVisited[featureNum] = true
        end
    end

    KnRBCheckFeature()
end

--events that should occur after placing a valid tile
function displayFigureButtons()
    local labelButtonParam = {
       index = 1, label = translate("BUTTON_LABEL_PROMPT_PLACE_FIGURE"), click_function = 'doNothing',
       position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=1.8}, width = 0, height=0, font_size = 200, function_owner = nil
    }
    createNormalizedArbitraryButton({x=-lastPlacedTileX * TILE_SPACING + MIDDLE_OFFSET.x, y=TABLE_SURFACE_Y, z=lastPlacedTileZ * TILE_SPACING - MIDDLE_OFFSET.z}, labelButtonParam, true)
    local skipFigureButtonParam = {
       index = 2, label = translate("BUTTON_LABEL_SKIP_PLACING_FIGURE"), click_function = 'skipFigureButton',
       position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=2.5}, width = 1400, height=600, font_size = 200, function_owner = nil
    }
    createNormalizedArbitraryButton({x=-lastPlacedTileX * TILE_SPACING + MIDDLE_OFFSET.x, y=TABLE_SURFACE_Y, z=lastPlacedTileZ * TILE_SPACING - MIDDLE_OFFSET.z}, skipFigureButtonParam, true)
    PnDDisplaySeducedKnightsButton()
    for _, obj in ipairs(getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()) do
        if obj.getVar('figureName') == 'Abbot' and obj.getVar('owner') == activePlayers[currentPlayer] then
            local xIndex, zIndex, _, _ = getFigureTileLocation(obj)
            if tileGridOccupied(xIndex, zIndex) then
                local retrieveAbbotButtonParam = {
                   index = 1, label = translate("BUTTON_LABEL_RETRIEVE_ABBOT"), click_function = 'retrieveAbbotButton',
                   position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=1.0}, width = 1400, height=600, font_size = 200, function_owner = nil
                }
                createNormalizedButton(obj, retrieveAbbotButtonParam, true)
                currentPlayerAbbot = obj.getGUID()
                return --there shouldn't be multiple abbots for each player, but stop just in case
            end
        end
    end
end

--display buttons during phantom placement phase
function displayPhantomButtons()
    local labelButtonParam = {
       index = 1, label = translate("BUTTON_LABEL_PROMPT_PLACE_PHANTOM"), click_function = 'doNothing',
       position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=1.8}, width = 0, height=0, font_size = 200, function_owner = nil
    }
    createNormalizedArbitraryButton({x=-lastPlacedTileX * TILE_SPACING + MIDDLE_OFFSET.x, y=TABLE_SURFACE_Y, z=lastPlacedTileZ * TILE_SPACING - MIDDLE_OFFSET.z}, labelButtonParam, true)
    local skipFigureButtonParam = {
       index = 2, label = translate("BUTTON_LABEL_SKIP_PHANTOM"), click_function = 'skipFigureButton',
       position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=2.5}, width = 1400, height=600, font_size = 200, function_owner = nil
    }
    createNormalizedArbitraryButton({x=-lastPlacedTileX * TILE_SPACING + MIDDLE_OFFSET.x, y=TABLE_SURFACE_Y, z=lastPlacedTileZ * TILE_SPACING - MIDDLE_OFFSET.z}, skipFigureButtonParam, true)
end

--creates a button, which is rotated according to the object's current rotation, so that the buttons always face up and towards the active player
--The positions of the buttons are also rotated to ignore the rotation of the object
function createNormalizedButton(obj, params, rotateToPlayer, customRotation)
    local player = activePlayers[currentPlayer]
    if currentMiniTurn ~= nil then
        player = activePlayers[currentMiniTurn]
    end
    if controlPanelSettings[player .. 'Control'] ~= nil then
        player = controlPanelSettings[player .. 'Control']
    end
    --default rotation is 180 degrees
    local playerRotation = 2
    local x, z
    if customRotation ~= nil then
        playerRotation = customRotation
        x, z = rotateCoordinates(params.position.x, params.position.z, customRotation)
    else
        if rotateToPlayer then
            playerRotation = player_possession_areas[player].rotation
        end
        x, z = rotateCoordinates(params.position.x, params.position.z, ((-playerRotation + 7) % 4) + 1)
    end
    params.position = {x=x, y=params.position.y, z=z}
    local pos = obj.getPosition()
    pos.x = pos.x + params.position.x
    pos.y = pos.y + params.position.y
    pos.z = pos.z + params.position.z
    pos = obj.positionToLocal(pos)
    params.position = {x=-pos.x, y=pos.y, z=pos.z}
    params.scale = {x=1/obj.getScale().x / 2, y=1/obj.getScale().y, z=1/obj.getScale().z / 2}

    local rotation = -obj.getRotation().y - (playerRotation * 90)
    --this method is currently bugged(?)
    --local rotation = (obj.getRotation().y * -1) + (Player[player].getPointerRotation())
    while rotation < 0 do rotation = rotation + 360 end
    params.rotation = {x=obj.getRotation().x, y=rotation, z=-obj.getRotation().z}
    obj.createButton(params)
end

function createNormalizedArbitraryButton(pivot_point, params, rotateToPlayer)
    local player = activePlayers[currentPlayer]
    if currentMiniTurn ~= nil then
        player = activePlayers[currentMiniTurn]
    end
    if controlPanelSettings[player .. 'Control'] ~= nil then
        player = controlPanelSettings[player .. 'Control']
    end
    --default rotation is 180 degrees
    local playerRotation = 2
    if rotateToPlayer then
        playerRotation = player_possession_areas[player].rotation
    end
    local x, z = rotateCoordinates(params.position.x, params.position.z, ((-playerRotation + 7) % 4) + 1)
    --params.position = {x=x, y=params.position.y, z=z}
    params.position = {x=x + pivot_point.x, y=params.position.y + pivot_point.y, z=z + pivot_point.z}

    local rotation = -(playerRotation * 90)
    --this method is currently bugged(?)
    --local rotation = (obj.getRotation().y * -1) + (Player[player].getPointerRotation())
    while rotation < 0 do rotation = rotation + 360 end
    params.rotation = {x=0, y=rotation, z=0}
    params.scale = {x=0.5, y=1.0, z=0.5}

    getObjectFromGUID(BUTTON_ANCHOR_GUID).createButton(params)
end

--dummy function for dummy button
function doNothing()
end

function skipFigureButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        if not confirmationDisplayed and controlPanelSettings['PnDFairy'] then
            confirmationDisplayed = true
            allGameMessage({"MESSAGE_SKIP_FAIRY_CONFIRMATION"}, WHITE_COLOR, activePlayers[currentPlayer])
        else
            return nextState('skip figure')
        end
    end
end

function retrieveAbbotButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        local xIndex, zIndex, xPosition, zPosition = getFigureTileLocation(object)
        if tileGridOccupied(xIndex, zIndex) then
            local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
            local closestTilePosition = findClosestTilePosition(xIndex, zIndex, xPosition, zPosition)
            local nameOfFeature = getTileFeatureName(tile, closestTilePosition)
            getFeatureComponents(xIndex, zIndex, closestTilePosition, 2, true)
            if nameOfFeature == 'Garden' or nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                score = #traversedTileCoords
                local player = object.getVar('owner')
                allGameMessage({"MESSAGE_ABBOT_RETRIEVE", {'{p1}', getPlayerOwnerName(player)}, {'{n1}', score}, {'{s1}', translate(nameOfFeature)}}, player_color_tints[player])
                statsScoredFeatures(player, nameOfFeature, false, {object}, nil, nil, score, score)
                scorePoints(player, nameOfFeature, score, true)
                table.insert(removedFigures, {guid=object.getGUID(), winner=true})
                object.setLock(false)
                object.use_gravity = false
                object.interactable = false
                --raise the follower in the air
                object.setPositionSmooth({object.getPosition().x, object.getPosition().y + 2.5, object.getPosition().z}, false, false)

                if showMarkers == 'Both' or showMarkers == 'Scoring' then
                    Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                else
                    returnFigures()
                end
                clearFigureOptions()
                return nextState('retrieve abbot')
            end
        end
    end
    allErrorMessage("Error: The abbot is currently on an invalid feature. Abbots can only be placed on gardens and cloisters.", activePlayers[currentPlayer])
end

function returnFollowerButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        --although we later remove these buttons, there is a slight delay during the figure removal, so we remove them now
        clearArbitraryButtons(true)
        for _, prisoner in ipairs(prisonersOfOtherPlayer) do
            prisoner.clearButtons()
        end

        table.insert(removedFigures, {guid=object.getGUID(), winner=false})
        allGameMessage({"MESSAGE_TOWER_EXCHANGE", {'{c1}', object.getDescription()}, {'{f1}', object.getName()}}, player_color_tints[object.getVar('owner')])
        return nextState('return followers')
    end
end

--adds any special figures that were dependent on this figure to the removed figure list
function removeDependentFigures(object)
    local xIndex, zIndex, xPosition, zPosition = getFigureTileLocation(object)
    if not tileGridOccupied(xIndex, zIndex) then
      allErrorMessage("ERROR: No tile detected at this figure. Was it moved? You may need to manually recover from this.", activePlayers[currentPlayer])
      return
    end
    local closestTilePosition = findClosestTilePosition(xIndex, zIndex, xPosition, zPosition)
    getFeatureComponents(xIndex, zIndex, closestTilePosition, 2, true)
    local followersCount = 0
    for _, follower in ipairs(traversedFollowers) do
        if follower.getGUID() ~= object.getGUID() and follower.getVar('owner') == object.getVar('owner') then
            followersCount = followersCount + 1
        end
    end
    if followersCount == 0 then
        for _, figure in ipairs(traversedSpecialFigures) do
            if TnBIsDependentFigure(figure) and figure.getVar('owner') == object.getVar('owner') then
                table.insert(removedFigures, {guid=figure.getGUID(), winner=false})
                allGameMessage({"MESSAGE_DEPENDENT_FIGURE_REMOVED", {'{p1}', getPlayerOwnerName(figure.getVar('owner'))}, {'{f1}', figure.getName()}}, player_color_tints[object.getVar('owner')])
            end
        end
    end
    -- run the coroutine to return figures from the removedFigures table (e.g. builders)
    -- otherwise they're only scheduled to be removed at some later point (until which they still count, which shouldn't be the case)
    returnFigures(true)
end

function clearFigureOptions()
    clearArbitraryButtons(true)
    flierClear()
    PnDFairyClear()
end

function clearArbitraryButtons(alsoClearHighlights)
    allPrisoners = towerGetPrisoners()
    for _, object in ipairs(getAllObjects()) do
        if tostring(object) == 'Card(Clone) (LuaGameObjectScript)' then
            if alsoClearHighlights then
                object.highlightOff()
            end
            object.clearButtons()
        elseif table.contains(FOLLOWER_TYPES, object.getVar('figureName')) or table.contains(SPECIAL_FIGURE_TYPES, object.getVar('figureName')) then
            local isPrisoner = false
            for player, prisoners in pairs(allPrisoners) do
                for _, prisoner in ipairs(prisoners) do
                    if prisoner == object then
                        isPrisoner = true
                        break
                    end
                end
            end
            if not isPrisoner then
                object.highlightOff()
                object.clearButtons()
            end
        end
    end
    if alsoClearHighlights then
        highlightLastPlacedTiles()
    end
    if lastPlacedTileX ~= nil then
        getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid).clearButtons()
    end
    if currentPlayerAbbot ~= nil then
        getObjectFromGUID(currentPlayerAbbot).clearButtons()
    end
    PnDClearSeducedKnightsButtons()
    HaSClearShepherdButtons()
    getObjectFromGUID(BUTTON_ANCHOR_GUID).clearButtons()
end

function highlightLastPlacedTiles()
    for player, coordinates in pairs(lastPlacedPlayerTiles) do
        if tileGridOccupied(coordinates.x, coordinates.z) then
            local tile = getObjectFromGUID(tileGrid[coordinates.x][coordinates.z].tile_guid)
            tile.highlightOn(player_color_tints[player])
        end
    end
end


function scoreFeatures()
    scoring = true
    local gameover = not gameIsActive()
    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
    for _, obj in ipairs(objs) do
        if table.contains(FOLLOWER_TYPES, obj.getVar('figureName')) or (gameover and obj.getVar('figureName') == 'Barn') then
            if not table.contains(followersScored, obj) then
                local xIndex, zIndex, xPosition, zPosition = getFigureTileLocation(obj)
                if tileGridOccupied(xIndex, zIndex) then
                    --debugMessage(1, "Checking " .. obj.getVar('owner') .. " " .. obj.getVar('tokenName') .. " for finished features at index: x: " .. xIndex .. " z: " .. zIndex)
                    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    local tileRotation = tileGrid[xIndex][zIndex].rotation
                    local closestTilePosition = findClosestTilePosition(xIndex, zIndex, xPosition, zPosition)
                    local closestFeatureMapPosition = tilePositionToFeatureMapPosition(closestTilePosition, tileRotation)
                    local featureNum = getFeatureNumAt(xIndex, zIndex, closestFeatureMapPosition)
                    if featureNum ~= nil then
                        getActiveFigures()
                        -- getActiveNeutralFigures()
                        local nameOfFeature = featureList[featureNum].nameOfFeature

                        --debugMessage(2, "figure closest feature: index: x: " .. xIndex .. " z: " .. zIndex .. " position: " .. closestTilePosition .. " name: " .. nameOfFeature)

                        local featureComplete
                        if featureList[featureNum].numOpenings == 0 then
                            featureComplete = true
                        else
                            featureComplete = false
                        end

                        local featureFollowers = {}
                        local featureSpecialFigures = {}
                        if activeFigures[featureNum] ~= nil then
                            featureFollowers = activeFigures[featureNum].followers
                            featureSpecialFigures = activeFigures[featureNum].specialFigures
                        end

                        local followerCounts = {}
                        local hasPig = {}
                        local hasHill = {}
                        local hasMayor = {}
                        local hasBarn = false
                        local hasNewBarn = false
                        local topWeight = -1
                        --find the relative weights for the followers on this feature
                        for _, follower in ipairs(featureFollowers) do
                            local weight = 0
                            local followerFigureName = follower.getVar('figureName')
                            if followerFigureName == 'Follower' or
                               followerFigureName == 'Wagon' or
                               followerFigureName == 'Phantom' or
                               followerFigureName == 'Abbot' then
                                   weight = 1
                            elseif followerFigureName == 'Big Follower' then
                                   weight = 2
                            elseif followerFigureName == 'Mayor' then
                                for _, specialFeature in ipairs(featureList[featureNum].specialFeatures) do
                                    if specialFeature == 'Pennant' then weight = weight + 1 end
                                end
                                hasMayor[follower.getVar('owner')] = true
                            end
                            if weight > 0 then
                                local followerXIndex, followerZIndex, _, _ = getFigureTileLocation(follower)
                                local specialFeatures = getTileDataForTile(getObjectFromGUID(tileGrid[followerXIndex][followerZIndex].tile_guid)).specialFeatures
                                if controlPanelSettings['HnSHills'] and specialFeatures ~= nil then
                                    for _, specialFeature in ipairs(specialFeatures) do
                                        if specialFeature[1] == "Hill" then
                                            --although it would have been easier to just add 0.001 to the weight here, it would have technically violated the rules, since multiple hills are not supposed to give extra weight.
                                            hasHill[follower.getVar('owner')] = true
                                        end
                                    end
                                end
                            end
                            if followerCounts[follower.getVar('owner')] == nil then
                                followerCounts[follower.getVar('owner')] = weight
                            else
                                followerCounts[follower.getVar('owner')] = followerCounts[follower.getVar('owner')] + weight
                            end
                        end
                        --add hill weight if there is a hill, find top weight for the feature
                        for player_color, value in pairs(followerCounts) do
                            if hasHill[player_color] then
                                --if the follower is on a hill, add a small value to it to break any ties
                                followerCounts[player_color] = followerCounts[player_color] + 0.001
                            end
                            if followerCounts[player_color] > topWeight then
                                topWeight = followerCounts[player_color]
                            end
                        end

                        for _, figure in ipairs(featureSpecialFigures) do
                            if figure.getVar('figureName') == 'Pig' then hasPig[figure.getVar('owner')] = true end
                            if figure.getVar('figureName') == 'Barn' then
                                hasBarn = true
                                if AnMIsNewBarn(figure) then
                                    hasNewBarn = true
                                    AnMClearNewBarn()
                                end
                                --recalculate "follower count" with only barns. Technically they aren't followers but it was easier in code.
                                if #featureFollowers == 0 then
                                    if followerCounts[figure.getVar('owner')] == nil then
                                        followerCounts[figure.getVar('owner')] = 1
                                    else
                                        followerCounts[figure.getVar('owner')] = followerCounts[figure.getVar('owner')] + 1
                                    end
                                    if followerCounts[figure.getVar('owner')] > topWeight then topWeight = followerCounts[figure.getVar('owner')] end
                                end
                            end
                        end
                        if #featureFollowers == 0 and not hasBarn then
                            allErrorMessage("ERROR: no followers found. This should never happen. Tell the dev.")
                            return
                        end
                        local score = 0
                        local numElements = 0   -- Base score for a feature.  Usually "number of tiles", but for fields would be number of cities closed
                        local containsPigHerd = false
                        if nameOfFeature == 'City' then
                            score = featureList[featureNum].numTiles
                            numElements = score
                            local containsCathedral = false
                            for _, feature in ipairs(featureList[featureNum].specialFeatures) do
                                if feature == 'Pennant' then
                                    score = score + 1
                                end
                                if feature == 'Cathedral' and controlPanelSettings['InCCathedrals'] then
                                    containsCathedral = true
                                end
                            end
                            if containsCathedral then
                                if featureComplete then
                                    score = score * 3
                                else
                                    score = 0
                                end
                            else
                                if featureComplete then
                                    score = score * 2
                                end
                            end
                            --do not nerf cities that were completed by an abbey, or incomplete cities
                            if lastPlacedTileX ~= nil and getTileDataForTile(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)).sides[1] ~= 'Abbey' and
                               featureComplete and controlPanelSettings['BaseNerfSmallCity'] and score == 4 then score = 2 end
                        elseif nameOfFeature == 'Field' then
                            if linkedFeatures['City-Field'][featureNum] ~= nil then
                                for connectedFeatureNum, _ in pairs(linkedFeatures['City-Field'][featureNum]) do
                                    if featureList[connectedFeatureNum].numOpenings == 0 then
                                        score = score + 1
                                    end
                                end
                                for _, feature in ipairs(featureList[featureNum].specialFeatures) do
                                    if feature == 'Pig-herd' and not controlPanelSettings['RIIDisablePigherd'] then
                                        containsPigHerd = true
                                    end
                                end
                            end
                            numElements = score
                            featureComplete = false --so that this feature won't be scored before the end of the game
                        elseif nameOfFeature == 'Road' then
                            score = featureList[featureNum].numTiles
                            numElements = score
                            local containsInn = false
                            for _, feature in ipairs(featureList[featureNum].specialFeatures) do
                                if feature == 'Inn' and controlPanelSettings['InCInns'] then
                                    containsInn = true
                                end
                            end
                            if containsInn then
                                if featureComplete then
                                    score = score * 2
                                else
                                    score = 0
                                end
                            end
                        elseif table.contains(CLOISTER_FEATURES, nameOfFeature) then
                            score = featureList[featureNum].numTiles
                            numElements = score
                            if featureComplete and controlPanelSettings['HnSVineyards'] then
                                for _, feature in ipairs(featureList[featureNum].specialFeatures) do
                                    if feature == 'Vineyard' then
                                        score = score + 3
                                    end
                                end
                            end
                            if featureComplete then
                                local challengerTile, challengedTile
                                if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                                    challengerTile = 'Cloister'
                                    challengedTile = 'Shrine'
                                else
                                    challengerTile = 'Shrine'
                                    challengedTile = 'Cloister'
                                end
                                for x=-1, 1 do
                                    for z=-1, 1 do
                                        if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
                                            local specialFeatures = getTileDataForTile(getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid)).specialFeatures
                                            if specialFeatures ~= nil then
                                                for i, feature in ipairs(specialFeatures) do
                                                    local adjacentFeature = feature[1]
                                                    if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                                    if adjacentFeature == challengedTile then
                                                        local numTiles = 0
                                                        for nested_x=-1, 1 do
                                                            for nested_z=-1, 1 do
                                                                if tileGridOccupied(xIndex + x + nested_x, zIndex + z + nested_z) then
                                                                    numTiles = numTiles + 1
                                                                end
                                                            end
                                                        end
                                                        if numTiles ~= 9 then
                                                            local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                                                            for _, object in ipairs(objs) do
                                                                if table.contains(FOLLOWER_TYPES, object.getVar('figureName')) then
                                                                    local objectXIndex, objectZIndex, xPosition, zPosition = getFigureTileLocation(object)
                                                                    if objectXIndex == xIndex + x and objectZIndex == zIndex + z then
                                                        				local nestedClosestTilePosition = findClosestTilePosition(xIndex + x, zIndex + z, xPosition, zPosition)
                                                                        if nestedClosestTilePosition == i + 12 then
                                                                            object.setLock(false)
                                                                            object.use_gravity = false
                                                                            object.interactable = false
                                                                            --raise the follower in the air
                                                                            object.setPositionSmooth({object.getPosition().x, object.getPosition().y + 2.5, object.getPosition().z}, false, false)
                                                                            table.insert(removedFigures, {guid=object.getGUID(), winner=false})
                                                                            allGameMessage({"MESSAGE_SHRINE_LOSE", {'{c1}', object.getDescription()}, {'{f1}', object.getName()}}, player_color_tints[object.getVar('owner')])
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        elseif nameOfFeature == "Baba Yaga's Hut" then
                            score = 10 - featureList[featureNum].numTiles
                            numElements = featureList[featureNum].numTiles
                            --unclear if vineyards should be counted. Leaving out for now
                        elseif nameOfFeature == "Garden" then
                            score = featureList[featureNum].numTiles
                            numElements = score
                        end
                        local numPlayersScoring = 0
                        for player, value in pairs(followerCounts) do
                            numPlayersScoring = numPlayersScoring+1
                        end
                        for player, value in pairs(followerCounts) do
                            if nameOfFeature ~= 'Carcassonne' and string.sub(nameOfFeature,1,8) ~= 'Quarter-' and string.sub(nameOfFeature,1,6) ~= 'Crown-' and nameOfFeature ~= 'Tower Foundation' and string.sub(nameOfFeature,1,6) ~= 'Flier' then
                                if gameover or featureComplete or (nameOfFeature == 'Field' and hasBarn and #featureFollowers > 0) or (gameover and hasBarn and #featureFollowers == 0) then
                                    if (topWeight > 0 and value >= topWeight) then
                                        local playerScore = score
                                        if nameOfFeature == 'Field' then
                                            local scoreMultiplier = 3
                                            if hasBarn then
                                                if #featureFollowers > 0 then
                                                    if not hasNewBarn then
                                                        scoreMultiplier = 1
                                                    end
                                                else
                                                    scoreMultiplier = 4
                                                end
                                            end
                                            if hasPig[player] ~= nil then
                                                scoreMultiplier = scoreMultiplier + 1
                                            end
                                            if containsPigHerd and #featureFollowers > 0 then -- CAR pg 67 ref 194
                                                scoreMultiplier = scoreMultiplier + 1
                                            end
                                            playerScore = score * scoreMultiplier
                                        end
                                        allGameMessage({"MESSAGE_SCORE", {'{p1}', getPlayerOwnerName(player)}, {'{n1}', playerScore}, {'{f1}', translate(nameOfFeature)}}, player_color_tints[player]) -- .. " with a strength of " .. value .. " followers", player_color_tints[player])
                                        statsScoredFeatures(player, nameOfFeature, featureComplete, featureFollowers, featureSpecialFigures, featureList[featureNum].specialFeatures, playerScore, numElements)
                                        scorePoints(player, nameOfFeature, playerScore, numPlayersScoring <= 1)
                                    elseif value > 0 then
                                        --allGameMessage(player .. " did not score any points with a strength of only " .. value .. " followers", player_color_tints[player])
                                    elseif topWeight == 0 and hasMayor[player] then
                                        allGameMessage({"MESSAGE_SCORE_MAYOR_NO_POINTS", {'{p1}', getPlayerOwnerName(player)}, {'{f1}', nameOfFeature}}, player_color_tints[player])
                                    end
                                end
                            end
                        end
                        for _, follower in ipairs(featureFollowers) do
                            if not table.contains(followersScored, follower) then
                                table.insert(followersScored, follower)
                            end
                        end
                        if gameover and #featureFollowers == 0 then
                            for _, figure in ipairs(featureSpecialFigures) do
                                if not table.contains(followersScored, figure) and figure.getVar('figureName') == 'Barn' then
                                    table.insert(followersScored, figure)
                                end
                            end
                        end
                        if nameOfFeature ~= 'Carcassonne' and string.sub(nameOfFeature,1,8) ~= 'Quarter-' and string.sub(nameOfFeature,1,6) ~= 'Crown-' and nameOfFeature ~= 'Tower Foundation' then
                            if gameover or featureComplete or (nameOfFeature == 'Field' and hasBarn) then
                                --The following is only used to check for traversedGoldBars
                                getFeatureComponents(xIndex, zIndex, closestTilePosition, 2, true)
                                for _, follower in ipairs(featureFollowers) do
                                    local eligibleFollowers = PnDFairyEligibleFollowers()
                                    for _, eligibleFollower in ipairs(eligibleFollowers) do
                                        if eligibleFollower == follower then
                                            allGameMessage({"MESSAGE_SCORE_FAIRY_FINISH", {'{p1}', getPlayerOwnerName(eligibleFollower.getVar('owner'))}, {'{f1}', eligibleFollower.getName()}}, player_color_tints[eligibleFollower.getVar('owner')])
                                            scorePoints(eligibleFollower.getVar('owner'), 'Fairy', 3, true)
                                        end
                                    end
                                    AnMSetWagonOwner(follower, featureNum)
                                    local winner = false
                                    if topWeight > 0 and followerCounts[follower.getVar('owner')] >= topWeight and score > 0 then winner = true end
                                    if winner and nameOfFeature ~= 'Field' and #traversedGoldBars > 0 then
                                        if scoringRewards['Gold'] == nil then scoringRewards['Gold'] = {} end
                                        for _, gold in ipairs(traversedGoldBars) do
                                            if scoringRewards['Gold'][gold.getGUID()] == nil then scoringRewards['Gold'][gold.getGUID()] = {} end
                                            if not table.contains(scoringRewards['Gold'][gold.getGUID()], follower.getVar('owner')) then
                                                table.insert(scoringRewards['Gold'][gold.getGUID()], follower.getVar('owner'))
                                            end
                                        end
                                    end
                                    table.insert(removedFigures, {guid=follower.getGUID(), winner=winner})
                                    follower.setLock(false)
                                    follower.use_gravity = false
                                    follower.interactable = false
                                    --raise the follower in the air
                                    follower.setPositionSmooth({follower.getPosition().x, follower.getPosition().y + 2.5, follower.getPosition().z}, false, false)
                                end
                                for _, figure in ipairs(featureSpecialFigures) do
                                    --shepherds are never removed outside of a flock collection
                                    --barns should only be scored at the end of the game, after all followers have been scored
                                    if figure.getVar('figureName') ~= 'Shepherd' and (figure.getVar('figureName') ~= 'Barn' or (figure.getVar('figureName') == 'Barn' and #featureFollowers == 0 and gameover)) then
                                        local winner = false
                                        --builder not involved in scoring, so shouldn't be praised
                                        if figure.getVar('figureName') ~= 'Builder' and topWeight > 0 and followerCounts[figure.getVar('owner')] >= topWeight and score > 0 then winner = true end
                                        table.insert(removedFigures, {guid=figure.getGUID(), winner=winner})
                                        figure.setLock(false)
                                        figure.use_gravity = false
                                        figure.interactable = false
                                        --raise the figure in the air
                                        figure.setPositionSmooth({figure.getPosition().x, figure.getPosition().y + 2.5, figure.getPosition().z}, false, false)
                                    end
                                end
                                if showMarkers == 'Both' or showMarkers == 'Scoring' then
                                    if gameover then
                                        praiseFiguresCameraFocus(false)
                                    end
                                    getFeatureComponents(xIndex, zIndex, closestTilePosition, 2, true)
                                    Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                                else
                                    returnFigures()
                                end
                                return
                            end
                        end
                    end
                end
            end
        end
    end
    if gameover then --do possessions now
        --TODO: Find a way to loop over the trade tokens without recommuting their values
        if TnBScoreFeatures('Wine Token') then
            return
        end
        if TnBScoreFeatures('Wheat Token') then
            return
        end
        if TnBScoreFeatures('Cloth Token') then
            return
        end
        if goldScoreFeatures() then
            return
        end
        resetTraversal()
        KnRBScoreFeature()
    end
    scoring = false
    followersScored = {}
    if gameover then
        printedPlayers = {}
        local playerNum = 1
        local rank = 1
        local lastHighscore = 0
        while true do
            local highscore = 0
            local color = nil
            for _, player in ipairs(activePlayers) do
                local scoreCounter = getObjectFromGUID(score_counter_guids[player])
                if not table.contains(printedPlayers, player) and scoreCounter ~= nil then
                    if scoreCounter.Counter.getValue() > highscore then
                        highscore = scoreCounter.Counter.getValue()
                        color = player
                    end
                end
            end
            if highscore > 0 then
                if highscore < lastHighscore then rank = playerNum end
                local steam_name = getPlayerOwnerName(color)
                allGameMessage({"#{n1} - {n2} points - {c1} - {p1}", {'{n1}', rank}, {'{n2}', highscore}, {'{c1}', color}, {'{p1}', steam_name}}, player_color_tints[color])
            else
                break
            end
            table.insert(printedPlayers, color)
            playerNum = playerNum + 1
            lastHighscore = highscore
        end

        for playerIndex, player in ipairs(activePlayers) do
            local scoreCounter = getObjectFromGUID(score_counter_guids[player])
            local statsMessage = getPlayerOwnerName(player) .. ": " .. scoreCounter.Counter.getValue() .. " points \n"
            for field, value in pairs(scoreSummary[player]) do
                local valuePercentage = ""
                if scoreCounter.Counter.getValue() > 0 then
                    valuePercentage = string.format(" (%d%%)", (value / scoreCounter.Counter.getValue())*100)
                end
                statsMessage = statsMessage .. field .. ": " .. value .. valuePercentage .. "\n"
            end
            for field, value in pairs(additionalPlayerStats[player]) do
                statsMessage = statsMessage .. field .. ": " .. value .. "\n"
            end

            allGameMessage(statsMessage, player_color_tints[player])
        end

        statsDisplayGlobalStats()

        allGameMessage({"MESSAGE_GAME_OVER"}, NEUTRAL_COLOR)
        return nextState('finished')
    else
        return nextState('next')
    end
end

--focus the camera on the currently praised figures
--params:
-- bool - only winning figures will be focused on
function praiseFiguresCameraFocus(onlyWinners)
    local camera_position = {x = 0.0, y = 0.0, z = 0.0}
    local num_winners = 0
    local max_separation = 0
    for _, figure in ipairs(removedFigures) do
        local figure_obj = getObjectFromGUID(figure.guid)
        if not onlyWinners or figure.winner then
            camera_position.x = camera_position.x + figure_obj.getPosition().x
            camera_position.y = camera_position.y + figure_obj.getPosition().y
            camera_position.z = camera_position.z + figure_obj.getPosition().z
            num_winners = num_winners + 1
            for _, other_figure in ipairs(removedFigures) do
                local other_figure_obj = getObjectFromGUID(other_figure.guid)
                local separation = math.sqrt((figure_obj.getPosition().x - other_figure_obj.getPosition().x) * (figure_obj.getPosition().x - other_figure_obj.getPosition().x) +
                          (figure_obj.getPosition().z - other_figure_obj.getPosition().z) * (figure_obj.getPosition().z - other_figure_obj.getPosition().z))
                if separation > max_separation then
                    max_separation = separation
                end
            end
        end
    end
    if num_winners > 0 then
        camera_position.x = camera_position.x / num_winners
        camera_position.y = camera_position.y / num_winners
        camera_position.z = camera_position.z / num_winners
    end
    for _, player in ipairs(activePlayers) do
        if getPlayerOwner(player):sub(1,2) ~= 'AI' and Player[getPlayerOwner(player)].seated then
            --getPointerRotation gives the player's current yaw (though +180 degrees). Use this to keep the yaw steady.
            local camera_yaw = Player[getPlayerOwner(player)].getPointerRotation() + 180
            if camera_yaw > 360 then camera_yaw = camera_yaw - 360 end
            local camera_params = {
                position = camera_position,
                yaw = camera_yaw,
                pitch = 35.0,
                --in theory this formula should give the camera distance needed to fit both objects in the screen
                --local camera_distance = math.tan((180 - fov) / 2) * (max_separation / 2)
                -- if the FoV is 90 degrees, then the altitude of the triangle is half the hypotenuse (which is the distance between the objects)
                -- is it correct? probably not, but it sounds good enough to me
                distance = 15.0 + (max_separation * 0.5)
            }
            Player[getPlayerOwner(player)].lookAt(camera_params)
        end
    end
end

function praiseFigures()
    --Slightly different code path if true
    gReturningShepherds = false

    startLuaCoroutine(self, 'praiseFiguresCoroutine')
end

--makes the winning followers spin and marks the features that were scored
function praiseFiguresCoroutine()
    local hasWinner = false
    for _, figure in ipairs(removedFigures) do
        if figure.winner then
            hasWinner = true
            getObjectFromGUID(figure.guid).addTorque({0,25,0}, 4)
        end
    end
    if hasWinner then
        getObjectFromGUID(SOUNDBOARD_GUID).AssetBundle.playTriggerEffect(0)
    end
    if showMarkers == 'Scoring' or showMarkers == 'Both' then
        for _, traversedTileCoord in ipairs(traversedTileCoords) do
            if traversedFeaturePositions[traversedTileCoord.x] ~= nil and traversedFeaturePositions[traversedTileCoord.x][traversedTileCoord.z] ~= nil then
                local tile = getObjectFromGUID(tileGrid[traversedTileCoord.x][traversedTileCoord.z].tile_guid)
                local tileData = getTileDataForTile(tile)

                local rotation = tileGrid[traversedTileCoord.x][traversedTileCoord.z].rotation
                local tileHeight = TILE_THICKNESS
                local specialFeatures = tileData.specialFeatures
                if specialFeatures ~= nil then
                    for _, specialFeature in ipairs(specialFeatures) do
                        if specialFeature[1] == "Hill" then
                            tileHeight = TILE_THICKNESS * 2
                        end
                    end
                end
                for position, traversedFeaturePosition in pairs(traversedFeaturePositions[traversedTileCoord.x][traversedTileCoord.z]) do
                    if position < 13 or specialFeatures[position - 12][3] ~= nil then
                        local x, z = getTileFeatureLocation(position, tile, rotation)
                        local params = {}
                        if traversedFeaturePosition == 1 then
                            params.type = "BlockSquare"
                        elseif traversedFeaturePosition == 2 then
                            if gReturningShepherds then break end
                            params.type = "BlockTriangle"
                        end
                        params.position = {(x * TILE_SPACING) + (traversedTileCoord.x * TILE_SPACING) - MIDDLE_OFFSET.x, TABLE_SURFACE_Y + tileHeight, (z * TILE_SPACING) + (traversedTileCoord.z * TILE_SPACING) - MIDDLE_OFFSET.z}
                        params.scale = {0.25, 0.25, 0.25}
                        params.callback = "identifyFeature"
                        params.sound = false
                        local newObject = spawnObject(params)
                        table.insert(featureMarkers, newObject)
                        if traversedFeaturePosition == 1 then
                            newObject.getComponent("BoxCollider").set("enabled", false)
                        elseif traversedFeaturePosition == 2 then
                            newObject.getComponent("MeshCollider").set("enabled", false)
                        end
                    end
                end
                coroutine.yield(0)
            end
        end
    end
    local returnFigureFunction = 'returnFigures'
    if gReturningShepherds then
        returnFigureFunction = 'HaSReturnShepherds'
    end
    Timer.create({identifier=os.clock(), function_name=returnFigureFunction, function_owner=nil, parameters=nil, delay=FIGURE_PRAISE_DELAY})
    return 1
end

--when we spawn an object (to mark a feature), immediately lock it
function identifyFeature(obj)
    obj.setLock(true)
end

function returnFigures(skipStates)

    --HACK: ransoming followers shouldn't progress the state machine
    if skipStates then
        skipStateProgression = true
    else
        skipStateProgression = false
    end
    startLuaCoroutine(self, 'returnFiguresCoroutine')
end

--send figures back to the player supply area (assuming that's where they were when the game started)
function returnFiguresCoroutine()
    deleteMarkers()
    for _, figure in ipairs(removedFigures) do
        local figure_obj = getObjectFromGUID(figure.guid)
        figure_obj.setLock(false)
        figure_obj.use_gravity = true
        figure_obj.interactable = true

        -- move the tokens away from the player possession area. It doesn't really matter where, as long as we move them so they aren't counted twice.
        if KnRBIsFigureReturned(figure_obj) then
            KnRBReturnFigure(figure_obj)
        elseif TnBIsFigureReturned(figure_obj) then
            TnBReturnFigure(figure_obj)
        elseif goldIsFigureReturned(figure_obj) then
            goldReturnFigure(figure_obj)
        else
            if figurePositions[figure_obj.getVar('owner')] ~= nil and figurePositions[figure_obj.getVar('owner')][figure_obj.getGUID()] ~= nil and getObjectFromGUID(figurepad_GUIDs[figure_obj.getVar('owner')]) ~= nil then
                local figurePad = getObjectFromGUID(figurepad_GUIDs[figure_obj.getVar('owner')])
                local x, z = rotateCoordinatesDegrees(figurePositions[figure_obj.getVar('owner')][figure_obj.getGUID()].x, figurePositions[figure_obj.getVar('owner')][figure_obj.getGUID()].z, -figurePad.getRotation().y)
                figure_obj.setLock(false)
                figure_obj.setPositionSmooth({x = figurePad.getPosition().x + x, y = figurePad.getPosition().y + 1, z = figurePad.getPosition().z + z}, false, false)
                figure_obj.setRotationSmooth({x=0, y=figurePad.getRotation().y, z=0})
            else
                allErrorMessage("Warning: " .. figure_obj.getName() .. " doesn't have a home and must be returned manually", activePlayers[currentPlayer])
            end
        end
        coroutine.yield(0)
    end
    removedFigures = {}

    --make sure to give enough time for pieces to travel back or they might be counted twice
    if not skipStateProgression then
        wait(FIGURE_RETURN_DELAY)
        nextState('figures returned')
    end
    return 1
end

function startAnimation(animation)
    function animate()
        local animation_finished = false
        local wheelCenterPosition = getWheelCenterPosition()
        while not animation_finished do
            if animation.type == 'WoFPig' then
                local pig = getObjectFromGUID(EXPANSION_BAGS['WoF'].contents['WoFPig'].guid)
                local time_elapsed = os.clock() - animation.start_time
                local degrees_rotated = (animation.start_position - 1) * 60
                if time_elapsed < ANIMATION_PIG_ACCEL_TIME then
                    --using d = (a * elapsed time^2) / 2
                    degrees_rotated = degrees_rotated + ANIMATION_PIG_ACCEL * time_elapsed * time_elapsed / 2
                elseif time_elapsed < ANIMATION_PIG_ACCEL_TIME + (ANIMATION_PIG_TIME_PER_SPACE * (animation.num_positions_moved - 1)) then
                    degrees_rotated = degrees_rotated + ANIMATION_PIG_ACCEL_DEGREES + (ANIMATION_PIG_MAX_VELOCITY * (time_elapsed - ANIMATION_PIG_ACCEL_TIME))
                elseif time_elapsed < ANIMATION_PIG_ACCEL_TIME * 2 + (ANIMATION_PIG_TIME_PER_SPACE * (animation.num_positions_moved - 1)) then
                    local time_decelerating = (time_elapsed - ANIMATION_PIG_ACCEL_TIME - ANIMATION_PIG_TIME_PER_SPACE * (animation.num_positions_moved - 1))
                    degrees_rotated = degrees_rotated + ANIMATION_PIG_ACCEL_DEGREES + (60 * (animation.num_positions_moved - 1)) +
                    -- using d = vi t + (a t * t) / 2
                        (ANIMATION_PIG_MAX_VELOCITY * time_decelerating) + (-ANIMATION_PIG_ACCEL * time_decelerating * time_decelerating / 2)
                else
                    degrees_rotated = degrees_rotated + 60 * animation.num_positions_moved
                    animation_finished = true
                end
                local x, z = rotateCoordinatesDegrees(wheelPigStartingOffset.x, wheelPigStartingOffset.z, -degrees_rotated)
                pig.setPosition({x=x + wheelCenterPosition.x, y=startingTileSettings['StartingTileWoF']['WoF']['WoFPig'].position.y, z=z + wheelCenterPosition.z})
                pig.setRotation({x=startingTileSettings['StartingTileWoF']['WoF']['WoFPig'].rotation.x, y=startingTileSettings['StartingTileWoF']['WoF']['WoFPig'].rotation.y, z=degrees_rotated})
            end
            coroutine.yield()
        end
        return 1
    end
    startLuaCoroutine(Global, "animate")
end

--Find the center
function getWheelCenterPosition()
    local x = 0
    local z = 0
    for _, i in ipairs({6, 7, 10, 11}) do
        local wheelCenterTile = getObjectFromGUID(EXPANSION_BAGS['WoF'].contents['WoFStartingTiles'].contents[i].guid)
        if wheelCenterTile == nil then return end
        local wheelCenterTilePosition = wheelCenterTile.getPosition()
        x = x + wheelCenterTilePosition.x
        z = z + wheelCenterTilePosition.z
    end
    x = x / 4
    z = z / 4
    return {x=x, z=z}
end

function pigIsEnabled()
    if controlPanelSettings['StartingTileWoF'] and
        (controlPanelSettings['WoFCrowns'] or controlPanelSettings['WoFFortune'] or controlPanelSettings['WoFTaxes'] or
        controlPanelSettings['WoFFamine'] or controlPanelSettings['WoFStorm'] or controlPanelSettings['WoFInquisition'] or
        controlPanelSettings['WoFPlague']) then
        return true
    end
    return false
end

function deleteMarkers()
    for _, featureMarker in ipairs(featureMarkers) do
        featureMarker.destruct()
    end
    featureMarkers = {}
end

--returns the x and z index of the tile that the figure is on, as well as the relative x and z position within that tile's area
function getFigureTileLocation(figure)
    local xIndex = math.floor((figure.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
    local zIndex = math.floor((figure.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
    local xPosition = (figure.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
    local zPosition = (figure.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
    xPosition = xPosition - xIndex
    zPosition = zPosition - zIndex
    return xIndex, zIndex, xPosition, zPosition
end

--wrapper for findClosestPosition, which rotates given coordinates to be aligned with a tile before getting the closestPosition
function findClosestTilePosition(xIndex, zIndex, xPosition, zPosition)
    --debugMessage(3, "finding closest feature for object at x:" .. xPosition .. " z:" .. zPosition .. " for rotation:" .. rotation)
    local tileRotation = tileGrid[xIndex][zIndex].rotation
    local rotatedXPosition, rotatedZPosition = rotateCoordinates(xPosition, zPosition, ((tileRotation + TILE_STANDARD_ROTATION - 1) % 4) + 1)

    local position = 1
    local closestPosition = 1
    local closestDistance = 999 --presumably every position should be closer than this

    local tileData = getTileDataForTile(getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid))
    for a = 0, 1 do -- a==0 is for quadrants, a==1 is for octants
        for side = 1, 4 do
            for j = 0, a do -- should do 1 loop for quadrants, 2 loops for octants
                if tileData.ignoredFeatures == nil or not table.contains(tileData.ignoredFeatures, position) then
                    local x, z = rotateCoordinates((-0.25 + (j * 0.5)) * a, 0.5 - FIGURE_DISTANCE_FROM_EDGE, 5 - side)
                    local distance = (rotatedXPosition - x) * (rotatedXPosition - x) + (rotatedZPosition - z) * (rotatedZPosition - z)
                    --debugMessage(3, "compare to position " .. position .. ": x: " .. x .. " z: " .. z .. " distance: " .. distance)
                    if distance < closestDistance then
                        closestPosition = position
                        closestDistance = distance
                    end
                end
                position = position + 1
            end
        end
    end
    local specialFeatures = tileData.specialFeatures
    if specialFeatures ~= nil then
        for specialFeatureNum, specialFeature in pairs(specialFeatures) do
            if specialFeature[3] ~= nil then
                local specialFeatureLocationX, specialFeatureLocationZ = rotateCoordinates(specialFeature[3][1], specialFeature[3][2], (TILE_STANDARD_ROTATION - 1 - tileGrid[xIndex][zIndex].rotation) % 4 + 1)
                local distance = (xPosition - specialFeatureLocationX) * (xPosition - specialFeatureLocationX) + (zPosition - specialFeatureLocationZ) * (zPosition - specialFeatureLocationZ)
                if distance < closestDistance then
                    closestPosition = specialFeatureNum+12
                    closestDistance = distance
                end
            end
        end
    end
    return closestPosition
end

--findClosestPosition
-- params:
--  int: xIndex
--  int: zIndex
--  float: xPosition - scaler value of a tile width (-0.5 to 0.5))
--  float: zPosition - scaler value of a tile height (-0.5 to 0.5))
-- returns:
--  int: 1-4 for quadrants, 5-12 for octants, 13.. for additional features
function findClosestPosition(xIndex, zIndex, xPosition, zPosition)
    --debugMessage(3, "finding closest feature for object at x:" .. xPosition .. " z:" .. zPosition .. " for rotation:" .. rotation)

    local position = 1
    local closestPosition = 1
    local closestDistance = 999 --presumably every position should be closer than this

    local tileData = getTileDataForTile(getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid))
    for a = 0, 1 do -- a==0 is for quadrants, a==1 is for octants
        for side = 1, 4 do
            for j = 0, a do -- should do 1 loop for quadrants, 2 loops for octants
                if tileData.ignoredFeatures == nil or not table.contains(tileData.ignoredFeatures, position) then
                    local x, z = rotateCoordinates((-0.25 + (j * 0.5)) * a, 0.5 - FIGURE_DISTANCE_FROM_EDGE, 5 - side)
                    local distance = (xPosition - x) * (xPosition - x) + (zPosition - z) * (zPosition - z)
                    --debugMessage(3, "compare to position " .. position .. ": x: " .. x .. " z: " .. z .. " distance: " .. distance)
                    if distance < closestDistance then
                        closestPosition = position
                        closestDistance = distance
                    end
                end
                position = position + 1
            end
        end
    end
    local specialFeatures = tileData.specialFeatures
    if specialFeatures ~= nil then
        for specialFeatureNum, specialFeature in pairs(specialFeatures) do
            if specialFeature[3] ~= nil then
                local specialFeatureLocationX, specialFeatureLocationZ = rotateCoordinates(specialFeature[3][1], specialFeature[3][2], (TILE_STANDARD_ROTATION - 1 - tileGrid[xIndex][zIndex].rotation) % 4 + 1)
                local distance = (xPosition - specialFeatureLocationX) * (xPosition - specialFeatureLocationX) + (zPosition - specialFeatureLocationZ) * (zPosition - specialFeatureLocationZ)
                if distance < closestDistance then
                    closestPosition = specialFeatureNum+12
                    closestDistance = distance
                end
            end
        end
    end
    return closestPosition
end

function getTileFeatureLocation(feature, tile, rotation)
    local x, z
    if feature < 13 then
        local a, side, j
        if feature < 5 then
            side = feature
            a = 0
            j = 0
        else
            side = math.floor((feature - 3) / 2)
            a = 1
            j = (feature - 3) % 2
        end
        x, z = rotateCoordinates((-0.25 + (j * 0.5)) * a, 0.5 - FIGURE_DISTANCE_FROM_EDGE, ((8 + TILE_STANDARD_ROTATION - side - rotation) % 4) + 1)
    else
        local tileData = getTileDataForTile(tile)
        local specialFeatures = tileData.specialFeatures
        x, z = rotateCoordinates(specialFeatures[feature - 12][3][1], specialFeatures[feature - 12][3][2], (TILE_STANDARD_ROTATION - 1 - rotation) % 4 + 1)
    end
    return x, z
end

function getFeatureLocation(xIndex, zIndex, feature)
    local x, z
    if feature < 13 then
        local a, side, j
        if feature < 5 then
            side = feature
            a = 0
            j = 0
        else
            side = math.floor((feature - 3) / 2)
            a = 1
            j = (feature - 3) % 2
        end
        x, z = rotateCoordinates((-0.25 + (j * 0.5)) * a, 0.5 - FIGURE_DISTANCE_FROM_EDGE, ((8 - side) % 4) + 1)
    else
        local tileData = getTileDataForTile(getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid))
        local specialFeatures = tileData.specialFeatures
        if specialFeatures ~= nil and specialFeatures[feature - 12][3] ~= nil then
            specialFeature = specialFeatures[feature - 12]
            x, z = rotateCoordinates(specialFeature[3][1], specialFeature[3][2], (TILE_STANDARD_ROTATION - 1 - tileGrid[xIndex][zIndex].rotation) % 4 + 1)
        end
    end
    return x, z
end

--getTileFeatureName
--
-- Gets the name of the feature on the tile at the specified position
--
-- params:
--  obj: tile
--  position: 1-12, 13-...
-- returns:
--  string: name
function getTileFeatureName(tile, position)
    local tileData = getTileDataForTile(tile)
    local nameOfFeature
    if position < 5 then
        nameOfFeature = tileData.sides[position]
    elseif position < 13 then
        local splitSides = string.split(tileData.sides[math.floor((position - 3) / 2)], "/")
        if #splitSides == 1 then
            nameOfFeature = splitSides[1]
            if nameOfFeature == 'Road' or nameOfFeature == 'River' then nameOfFeature = 'Field' end
        else
            if position % 2 == 1 then
                nameOfFeature = splitSides[1]
            else
                nameOfFeature = splitSides[2]
            end
        end
    else
        local specialFeatures = tileData.specialFeatures
        if specialFeatures[position - 12] ~= nil then
            nameOfFeature = specialFeatures[position - 12][1]
        else
            nameOfFeature = "ERROR: Feature at position " .. position .. " doesn't exist"
        end
    end
    return nameOfFeature
end
