--These functions store basic information about the features on the tiles, along with a feature map in order to arbitrarily find those feastures
--This new system is intended to replace the old method of using recusion to traverse the tiles, which should save time when the AI is making decisions
--recursion is still needed when removing tiles, but this should be a rare event

function addTile(xIndex, zIndex, tile, rotation, temp, auto)
    --note: if this function is called with temp=true, you must separately clear tileGrid[xIndex][zIndex] to nil once you are finished
    local tileData = getTileDataForTile(tile)
    if tileGrid[xIndex] == nil then tileGrid[xIndex] = {} end
    tileGrid[xIndex][zIndex] = {}
    tileGrid[xIndex][zIndex].tile_guid = tile.getGUID()
    tileGrid[xIndex][zIndex].rotation = rotation
    tileGrid[xIndex][zIndex].featureMap = {}
    if temp then --do not modify the original data. If anything is modified, make a copy of it before modifying
        tempLinkedFeatures = {['City-Field'] = {}, ['Road Intersection'] = {}}
        tempValidTileLocations = {}
        tempTileConnectionOdds = {}
        tempFeatureIndex = featureIndex
        tempFeatureList = {}
        tempJoinedFeature = {}
    else
        --if the newest tile is at the edge of the play area, then shift it if there is room
        --https://stackoverflow.com/a/1252776
        local next = next
        if xIndex == MIN_X and (tileGrid[MAX_X] == nil or next(tileGrid[MAX_X]) == nil) then
            shiftPlayArea(1, 0)
            xIndex = xIndex + 1
        end
        if xIndex == MAX_X and (tileGrid[MIN_X] == nil or next(tileGrid[MIN_X]) == nil) then
            shiftPlayArea(-1, 0)
            xIndex = xIndex - 1
        end
        if zIndex == MIN_Z then
            local atEdge = false
            for _, tileColumn in pairs(tileGrid) do
                if tileColumn[MAX_Z] ~= nil then
                    atEdge = true
                    break
                end
            end
            if not atEdge then
                shiftPlayArea(0, 1)
                zIndex = zIndex + 1
            end
        end
        if zIndex == MAX_Z then
            local atEdge = false
            for _, tileColumn in pairs(tileGrid) do
                if tileColumn[MIN_Z] ~= nil then
                    atEdge = true
                    break
                end
            end
            if not atEdge then
                shiftPlayArea(0, -1)
                zIndex = zIndex - 1
            end
        end
        if tile.getGUID() == finalTile_GUID then
            finalTile_GUID = nil
        end

        lastPlacedTileX = xIndex
        lastPlacedTileZ = zIndex
        --highlight the last tile played by a player, not when a tile is
        --placed automatically during setup
        if not auto then
            if lastPlacedPlayerTiles[activePlayers[currentPlayer]] ~= nil then
                local coordinates = lastPlacedPlayerTiles[activePlayers[currentPlayer]]
                if tileGridOccupied(coordinates.x, coordinates.z) then
                    local tile = getObjectFromGUID(tileGrid[coordinates.x][coordinates.z].tile_guid)
                    tile.highlightOff()
                end
            end
            lastPlacedPlayerTiles[activePlayers[currentPlayer]] = {x=xIndex, z=zIndex}
        end
    end
    local targetLinkedFeatures
    local targetFeatureList
    if temp then
        targetLinkedFeatures = tempLinkedFeatures
        targetFeatureList = tempFeatureList
    else
        targetLinkedFeatures = linkedFeatures
        targetFeatureList = featureList
    end
    local visitedFeatures = {}
    local specialFeatures = tileData.specialFeatures
    local numSpecialFeatures = 0
    local invalidatedFeatureCoordinates = {}
    local alreadyAddedFeatures = {} --to handle a special case where the same feature can be merged by multiple separate features on the tile, in which case numTiles should only be increased once
    if specialFeatures ~= nil then numSpecialFeatures = #specialFeatures end
    local numFeatures = 12 + numSpecialFeatures
    for position=1, numFeatures do
        local nameOfFeature = getTileFeatureName(tile, position)
        if (position > 4 or nameOfFeature == 'Road' or nameOfFeature == 'River' or nameOfFeature == 'Abbey') and not (position > 12 and specialFeatures[position-12][3] == nil) and not visitedFeatures[position] then
            local featurePositions = {}
            local linkedSpecialFeatures = {}
            local connectedFeatures = {}
            local numOpenings = 0
            local featureOpeningCoords = {}
            local links = nil

            if position < 5 then
                links = getLinkedQuadrants(tile)
            elseif position < 13 then
                links = tileData.linkedOctants
            end
            local visitedPosition = false
            while not visitedPosition do
                if links ~= nil then
                    for _, link in ipairs(links) do
                        --HACK: Because quadrants and octants can't be linked, Abbeys create a scenario where they get different feature numbers.
                        --The least hacky way I could fix it (without having to redo huge chunks of code) was as follows, in addition to linking all 12 positions to the 13th on the tiles...
                        if nameOfFeature == 'Abbey' and position < 13 then
                            link = {1,2,3,4,5,6,7,8,9,10,11,12,13}
                        end
                        if table.contains(link, position) then
                            visitedPosition = true
                            for _, nestedPosition in ipairs(link) do
                                featurePositions[nestedPosition] = true
                                if nestedPosition < 13 then
                                    local connectedFeatureMapPosition, connectedX, connectedZ = getConnectingFeatureMapPosition(xIndex, zIndex, nestedPosition, rotation)
                                    if tileGridOccupied(connectedX, connectedZ) and tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition] ~= nil then
                                        if nameOfFeature ~= 'Abbey' then
                                            numOpenings = numOpenings - 1
                                            if not table.contains(connectedFeatures, tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition]) then
                                                table.insert(connectedFeatures, tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition])
                                            end
                                        else
                                            if temp and tempFeatureList[tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition]] == nil then
                                                tempFeatureList[tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition]] = {}
                                            end
                                            targetFeatureList[tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition]].numOpenings = featureList[tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition]].numOpenings - 1
                                        end
                                    elseif nameOfFeature ~= 'Abbey' then
                                        numOpenings = numOpenings + 1
                                        featureOpeningCoords[connectedX .. "-" .. connectedZ] = true
                                    end
                                end
                            end
                        end
                    end
                end
                if not visitedPosition then
                    links = {{position}}
                end
            end
            if specialFeatures ~= nil then
                for i, feature in ipairs(specialFeatures) do
                    if feature[2] ~= nil then
                        if table.contains(feature[2], position) then
                            if feature[3] ~= nil then
                                featurePositions[i+12] = true
                            elseif feature[1] ~= 'City-Field' and feature[1] ~= 'Road Intersection' then
                                --Make a list of special features that should be linked (City-Field and Road Intersection have a separate system stored in linkedFeatures. This is done later)
                                table.insert(linkedSpecialFeatures, feature[1])
                            end
                        end
                    end
                end
            end

            local newFeatureIndex
            if #connectedFeatures > 0 then --this feature joined with an existing one, so we'll just add to that
                newFeatureIndex = connectedFeatures[1]

                if temp then
                    if tempFeatureList[newFeatureIndex] == nil then
                        tempFeatureList[newFeatureIndex] = {}
                    end
                    tempFeatureList[newFeatureIndex].specialFeatures = table.shallow_copy(featureList[newFeatureIndex].specialFeatures)
                    tempFeatureList[newFeatureIndex].nameOfFeature = featureList[newFeatureIndex].nameOfFeature
                end

                for _, specialFeature in ipairs(linkedSpecialFeatures) do
                    table.insert(targetFeatureList[newFeatureIndex].specialFeatures, specialFeature)
                end
                targetFeatureList[newFeatureIndex].numOpenings = featureList[newFeatureIndex].numOpenings + numOpenings
                for key, opening in pairs(featureList[newFeatureIndex].openingCoords) do
                    if key ~= xIndex .. "-" .. zIndex then
                        featureOpeningCoords[key] = true
                    end
                end
                targetFeatureList[newFeatureIndex].openingCoords = featureOpeningCoords
                if nameOfFeature == 'Field' then
                    targetFeatureList[newFeatureIndex].numTiles = 0
                elseif alreadyAddedFeatures[newFeatureIndex] ~= true then
                    targetFeatureList[newFeatureIndex].numTiles = featureList[newFeatureIndex].numTiles + 1
                end

                if temp then
                    if linkedFeatures['City-Field'][newFeatureIndex] ~= nil then
                        tempLinkedFeatures['City-Field'][newFeatureIndex] = table.shallow_copy(linkedFeatures['City-Field'][newFeatureIndex])
                    end
                    if linkedFeatures['Road Intersection'][newFeatureIndex] ~= nil then
                        tempLinkedFeatures['Road Intersection'][newFeatureIndex] = table.shallow_copy(linkedFeatures['Road Intersection'][newFeatureIndex])
                    end
                end

                if #connectedFeatures > 1 then --this feature merged with more than one feature, so we'll need to do a bit more work to merge them
                    local visitedTiles = {}
                    for i, connectedFeatureNum in ipairs(connectedFeatures) do
                        --if this feature has already been connected to another, then this feature should connect to that one instead
                        if temp and tempJoinedFeature[connectedFeatureNum] ~= nil then
                            newConnectedFeatureNum = newFeatureIndex
                            newFeatureIndex = tempJoinedFeature[connectedFeatureNum]
                            connectedFeatureNum = newConnectedFeatureNum
                        end
                        for linkType, originFeatures in pairs(linkedFeatures) do
                            if linkedFeatures[linkType][connectedFeatureNum] ~= nil then
                                for destinationFeature, _ in pairs(linkedFeatures[linkType][connectedFeatureNum]) do
                                    if destinationFeature ~= newFeatureIndex then --don't copy a reference to itself
                                        if linkedFeatures[linkType][newFeatureIndex] == nil then
                                            targetLinkedFeatures[linkType][newFeatureIndex] = {}
                                        end
                                        targetLinkedFeatures[linkType][newFeatureIndex][destinationFeature] = true
                                    end
                                end
                            end
                            for originFeature, _ in pairs(originFeatures) do
                                if originFeature ~= newFeatureIndex then --don't copy a reference to itself
                                    if linkedFeatures[linkType][originFeature][connectedFeatureNum] ~= nil then
                                        if temp then
                                            --if a link needs to be changed then it needs to be copied from the original table if it exists
                                            if tempLinkedFeatures[linkType][originFeature] == nil then
                                                if linkedFeatures[linkType][originFeature] ~= nil then
                                                    tempLinkedFeatures[linkType][originFeature] = table.shallow_copy(linkedFeatures[linkType][originFeature])
                                                else
                                                    tempLinkedFeatures[linkType][originFeature] = {}
                                                end
                                            end
                                        else
                                            if linkedFeatures[linkType][originFeature] == nil then
                                                linkedFeatures[linkType][originFeature] = {}
                                            end
                                        end
                                        targetLinkedFeatures[linkType][originFeature][newFeatureIndex] = true
                                    end
                                end
                            end
                        end
                        if i == 1 then
                            if nameOfFeature ~= 'Field' then
                                for nestedX, featureColumn in pairs(tileGrid) do
                                    for nestedZ, gridPositionData in pairs(featureColumn) do
                                        for nestedFeaturePosition, featureNum in pairs(gridPositionData.featureMap) do
                                            if featureNum == connectedFeatureNum then
                                                if visitedTiles[nestedX] == nil then visitedTiles[nestedX] = {} end
                                                visitedTiles[nestedX][nestedZ] = true
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        else --if 2 or more features have been merged to one, we should combine all special features, add the numOpenings to each other, and recalculate numTiles
                            for _, specialFeature in ipairs(featureList[connectedFeatureNum].specialFeatures) do
                                table.insert(targetFeatureList[newFeatureIndex].specialFeatures, specialFeature)
                            end
                            targetFeatureList[newFeatureIndex].numOpenings = targetFeatureList[newFeatureIndex].numOpenings + featureList[connectedFeatureNum].numOpenings
                            for openingCoord, _ in pairs(featureList[connectedFeatureNum].openingCoords) do
                                if openingCoord ~= xIndex .. "-" .. zIndex then
                                    targetFeatureList[newFeatureIndex].openingCoords[openingCoord] = true
                                    invalidatedFeatureCoordinates[openingCoord] = true
                                end
                            end
                            if temp then
                                tempJoinedFeature[connectedFeatureNum] = newFeatureIndex
                            end
                            for nestedX, featureColumn in pairs(tileGrid) do
                                for nestedZ, gridPositionData in pairs(featureColumn) do
                                    for nestedFeature, featureNum in pairs(gridPositionData.featureMap) do
                                        if featureNum == connectedFeatureNum then
                                            --print("featureNum " .. newFeatureIndex .. " on x:" .. nestedX .. " y:" .. nestedZ .. " assigned to position " .. nestedFeature)
                                            if not temp then
                                                tileGrid[nestedX][nestedZ].featureMap[nestedFeature] = newFeatureIndex
                                            end
                                            if nameOfFeature ~= 'Field' then
                                                if visitedTiles[nestedX] == nil then visitedTiles[nestedX] = {} end
                                                if not visitedTiles[nestedX][nestedZ] then
                                                    --since there's a chance that multiple features occupy the same tile, we can't trust the numTiles property of this feature and must recount
                                                    targetFeatureList[newFeatureIndex].numTiles = targetFeatureList[newFeatureIndex].numTiles + 1
                                                    visitedTiles[nestedX][nestedZ] = true
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            if not temp then
                                featureList[connectedFeatureNum] = nil
                                for linkType, originFeatures in pairs(linkedFeatures) do
                                    for origin, _ in pairs(originFeatures) do
                                        linkedFeatures[linkType][origin][connectedFeatureNum] = nil
                                    end
                                    linkedFeatures[linkType][connectedFeatureNum] = nil
                                end
                            end
                        end
                    end
                end
                alreadyAddedFeatures[newFeatureIndex] = true
            else --this feature didn't merge with any existing one, so it is brand new and should be initialized and given a new feature number
                if temp then
                    newFeatureIndex = tostring(tempFeatureIndex)
                    tempFeatureIndex = tempFeatureIndex + 1
                else
                    newFeatureIndex = tostring(featureIndex)
                    featureIndex = featureIndex + 1
                end
                targetFeatureList[newFeatureIndex] = {}
                targetFeatureList[newFeatureIndex].nameOfFeature = nameOfFeature
                targetFeatureList[newFeatureIndex].specialFeatures = linkedSpecialFeatures
                targetFeatureList[newFeatureIndex].numOpenings = numOpenings
                targetFeatureList[newFeatureIndex].openingCoords = featureOpeningCoords
                if table.contains(PROXIMITY_FEATURES, nameOfFeature) then
                    targetFeatureList[newFeatureIndex].featureLocation = {x=xIndex, z=zIndex}
                    targetFeatureList[newFeatureIndex].numTiles = 1
                    for i, offset in ipairs(DIAGONAL_DELTA) do
                        local neighborX = xIndex + offset.x
                        local neighborZ = zIndex + offset.z
                        if tileGridOccupied(neighborX, neighborZ) then
                            targetFeatureList[newFeatureIndex].numTiles = targetFeatureList[newFeatureIndex].numTiles + 1
                            local neighborTile = getObjectFromGUID(tileGrid[neighborX][neighborZ].tile_guid)
                            local neighborTileData = getTileDataForTile(neighborTile)
                            local neighborRotation = tileGrid[neighborX][neighborZ].rotation
                            local neighborSpecialFeatures = neighborTileData.specialFeatures
                            if neighborSpecialFeatures ~= nil then
                                for _, neighborSpecialFeature in ipairs(neighborSpecialFeatures) do
                                    if neighborSpecialFeature[1] == 'Vineyard' then
                                        table.insert(linkedSpecialFeatures, neighborSpecialFeature[1])
                                    end
                                end
                            end
                        else
                            targetFeatureList[newFeatureIndex].openingCoords[neighborX .. "-" .. neighborZ] = true
                        end
                    end
                    targetFeatureList[newFeatureIndex].numOpenings = 9 - targetFeatureList[newFeatureIndex].numTiles
                elseif nameOfFeature ~= 'Field' then
                    targetFeatureList[newFeatureIndex].numTiles = 1
                else
                    targetFeatureList[newFeatureIndex].numTiles = 0
                end
            end
            for nestedTilePosition, featurePosition in pairs(featurePositions) do
                local nestedFeatureMapPosition = tilePositionToFeatureMapPosition(nestedTilePosition, rotation)
                tileGrid[xIndex][zIndex].featureMap[nestedFeatureMapPosition] = newFeatureIndex
                visitedFeatures[nestedTilePosition] = true
            end
        end
    end

    local addToProximityFeatures = {}
    if specialFeatures ~= nil then
        for specialFeatureNum, feature in ipairs(specialFeatures) do
            local nameOfFeature = feature[1]
            if nameOfFeature == 'City-Field' or nameOfFeature == 'Road Intersection' then --if this specialFeature is a "linked feature", add it to the linkedFeatures map
                local nestedLinkedFeatures = {}
                for _, nestedTilePosition in ipairs(feature[2]) do
                    local nestedFeatureMapPosition = tilePositionToFeatureMapPosition(nestedTilePosition, rotation)
                    local featureNum = tileGrid[xIndex][zIndex].featureMap[nestedFeatureMapPosition]
                    if not table.contains(nestedLinkedFeatures, featureNum) then
                        table.insert(nestedLinkedFeatures, featureNum)
                    end
                end
                for _, nestedLinkedFeature in ipairs(nestedLinkedFeatures) do
                    if targetLinkedFeatures[nameOfFeature][nestedLinkedFeature] == nil then
                        targetLinkedFeatures[nameOfFeature][nestedLinkedFeature] = {}
                    end
                    for _, nestedNestedLinkedFeature in ipairs(nestedLinkedFeatures) do
                        if nestedLinkedFeature ~= nestedNestedLinkedFeature and (nameOfFeature == 'Road Intersection' or targetFeatureList[nestedNestedLinkedFeature].nameOfFeature ~= targetFeatureList[nestedLinkedFeature].nameOfFeature) then
                            targetLinkedFeatures[nameOfFeature][nestedLinkedFeature][nestedNestedLinkedFeature] = true
                        end
                    end
                end
            elseif nameOfFeature == 'Vineyard' then --if this tile contains specialFeatures relevant to neighboring tiles, add them to a list (there should only ever be one proximity feature per tile, but I'm leaving it open to shenanigan fan tiles)
                table.insert(addToProximityFeatures, feature[1])
            end
        end
    end

    --if there is a nearby proximity feature, make sure to count this tile. Also add any previously found addToProximityFeatures
    for _, offset in ipairs(DIAGONAL_DELTA) do
        local neighborX = xIndex + offset.x
        local neighborZ = zIndex + offset.z
        if tileGridOccupied(neighborX, neighborZ) then
            for neighborPositionNum, neighborFeatureNum in pairs(tileGrid[neighborX][neighborZ].featureMap) do
                if table.contains(PROXIMITY_FEATURES, featureList[neighborFeatureNum].nameOfFeature) and neighborPositionNum > 12 then --HACK: Only consider positions over 12 so that abbeys aren't counted multiple times
                    if temp then
                        tempFeatureList[neighborFeatureNum] = table.deep_copy(featureList[neighborFeatureNum])
                    end
                    targetFeatureList[neighborFeatureNum].numTiles = targetFeatureList[neighborFeatureNum].numTiles + 1
                    targetFeatureList[neighborFeatureNum].numOpenings = targetFeatureList[neighborFeatureNum].numOpenings - 1
                    targetFeatureList[neighborFeatureNum].openingCoords[xIndex .. "-" .. zIndex] = nil
                    for _, neighborSpecialFeature in ipairs(addToProximityFeatures) do
                        table.insert(targetFeatureList[neighborFeatureNum].specialFeatures, neighborSpecialFeature)
                    end
                end
            end
        end
    end

    --If validTileLocations is nil, then either AI is disabled or in a bad state. Either way,
    --all AI data will be recalculated at the beginning of the next AI player's turn
    if validTileLocations ~= nil then
        AITileAdded(xIndex, zIndex, tile, rotation, temp)
        local targetTileConnectionOdds
        if temp then
            targetTileConnectionOdds = tempTileConnectionOdds
        else
            targetTileConnectionOdds = tileConnectionOdds
        end
        for openingCoord, _ in pairs(invalidatedFeatureCoordinates) do
            if openingCoord ~= xIndex .. "-" .. zIndex then
                local coord = string.split(openingCoord, "-")
                local x = tonumber(coord[1])
                local z = tonumber(coord[2])

                targetTileConnectionOdds[openingCoord] = AICalculateLocationOdds(openingCoord, x, z, xIndex, zIndex, temp)
            end
        end
    end
    if not temp then
        tileInPlay = true
    end
end

function removeTile(xIndex, zIndex, removedTile)
    --the best way I could figure out to divide features that are split is to
    --remove all features on the tile from the entire featureMap,
    --then recursively re-add neighboring nil features

    local removedTileData = getTileDataForTile(removedTile)
    for _, featureNum in pairs(tileGrid[xIndex][zIndex].featureMap) do
        --remove features
        featureList[featureNum] = nil
        for nestedX, featureColumn in pairs(tileGrid) do
            for nestedZ, gridPositionData in pairs(featureColumn) do
                for nestedFeaturePosition, nestedFeatureNum in pairs(gridPositionData.featureMap) do
                    if nestedFeatureNum == featureNum then
                        --remove from feature map
                        tileGrid[nestedX][nestedZ].featureMap[nestedFeaturePosition] = nil
                    end
                end
            end
        end

        --remove links
        for featureType, linkedSubFeatures in pairs(linkedFeatures) do
            linkedFeatures[featureType][featureNum] = nil
            for feature, _ in pairs(linkedSubFeatures) do
                if linkedFeatures[featureType][feature][featureNum] ~= nil then
                    linkedFeatures[featureType][feature][featureNum] = nil
                end
            end
        end
    end

    tileGrid[xIndex][zIndex] = nil

    local tempLinkedFeatures = {['City-Field'] = {}, ['Road Intersection'] = {}}

    for position=1, 12 do
        local connectedFeatureMapPosition, connectedX, connectedZ = getConnectingFeatureMapPosition(xIndex, zIndex, position, TILE_STANDARD_ROTATION)

        if tileGridOccupied(connectedX, connectedZ) then
            local connectedTile = getObjectFromGUID(tileGrid[connectedX][connectedZ].tile_guid)
            local connectedTileRotation = tileGrid[connectedX][connectedZ].rotation
            local connectedTilePosition = featureMapPositionToTilePosition(connectedFeatureMapPosition, tileGrid[connectedX][connectedZ].rotation)

            local nameOfFeature = getTileFeatureName(connectedTile, connectedTilePosition)

            --Abbey tiles are removed in a much different way than other tiles
            --if an Abbey:
            --  none of the neighboring features were not part of the tile, so they don't need to be recalculated. Instead, just add openings to each of the neighboring features.
            --if not an Abbey:
            --  we have no real way of knowing how the feature metadata may have been made constructed; adding a tile is a one-way road. We'll have to traverse the entire feature
            --  in order to rebuild it and assign a new feature number
            if removedTileData.sides[1] == 'Abbey' then
                -- don't do anything if the neighboring tile is also an Abbey (this should technically be impossible, but just in case)
                if nameOfFeature ~= 'Abbey' and tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition] ~= nil then
                    local connectedFeatureNum = getFeatureNumAt(connectedX, connectedZ, connectedFeatureMapPosition)
                    featureList[connectedFeatureNum].openingCoords[xIndex .. "-" .. zIndex] = true
                    if position > 4 or nameOfFeature == 'Road' or nameOfFeature == 'River' then
                        featureList[connectedFeatureNum].numOpenings = featureList[connectedFeatureNum].numOpenings + 1
                    end
                end
            elseif (position > 4 or nameOfFeature == 'Road' or nameOfFeature == 'River') and tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition] == nil then
                --print(position .. ": checking x:" .. connectedX .. " z:" .. connectedZ .. " tilePosition:" .. connectedTilePosition .. " connectedFeatureMapPosition:" .. connectedFeatureMapPosition)
                local numOpenings = getFeatureComponents(connectedX, connectedZ, connectedTilePosition, 2, true, nameOfFeature == 'City')

                newFeatureIndex = tostring(featureIndex)
                featureIndex = featureIndex + 1

                featureList[newFeatureIndex] = {}
                featureList[newFeatureIndex].nameOfFeature = nameOfFeature
                local specialFeatures = {}
                for i, specialFeature in ipairs(traversedSpecialFeatures) do
                    if specialFeature ~= 'Road Intersection' and specialFeature ~= 'City-Field' and specialFeature ~= 'Completed City' then
                        table.insert(specialFeatures, specialFeature)
                    end
                end
                featureList[newFeatureIndex].specialFeatures = traversedSpecialFeatures
                featureList[newFeatureIndex].numOpenings = numOpenings
                featureList[newFeatureIndex].openingCoords = traversedOpeningCoords
                if nameOfFeature ~= 'Field' then
                    featureList[newFeatureIndex].numTiles = #traversedTileCoords
                else
                    featureList[newFeatureIndex].numTiles = 0
                end
                if table.contains(PROXIMITY_FEATURES, nameOfFeature) then
                    featureList[newFeatureIndex].featureLocation = {x=connectedX, z=connectedZ}
                end
                tempLinkedFeatures['City-Field'][newFeatureIndex] = {}
                tempLinkedFeatures['Road Intersection'][newFeatureIndex] = {}
                for nestedXIndex, gridColumn in pairs(traversedFeaturePositions) do
                    for nestedZIndex, tileLocation in pairs(gridColumn) do
                        local nestedTile = getObjectFromGUID(tileGrid[nestedXIndex][nestedZIndex].tile_guid)
                        local nestedTileData = getTileDataForTile(nestedTile)
                        local nestedTileRotation = tileGrid[nestedXIndex][nestedZIndex].rotation
                        for nestedTilePosition, traversedFeaturePosition in pairs(tileLocation) do
                            --print("traversing " .. newFeatureIndex .. " to x: " .. nestedXIndex .. " z: " .. nestedZIndex .. " pos: " .. nestedTilePosition)
                            if nestedTilePosition < 13 or nestedTileData.specialFeatures[nestedTilePosition - 12][3] ~= nil then
                                if nestedTilePosition > 4 or nameOfFeature == 'Road' or nameOfFeature == 'River' then
                                    local nestedFeatureMapPosition = tilePositionToFeatureMapPosition(nestedTilePosition, nestedTileRotation)
                                    if traversedFeaturePosition == 1 then
                                        --print("assigning " .. newFeatureIndex .. " to x: " .. nestedXIndex .. " z: " .. nestedZIndex .. " featureMapPos: " .. nestedFeatureMapPosition .. " pos: " .. nestedTilePosition)
                                        tileGrid[nestedXIndex][nestedZIndex].featureMap[nestedFeatureMapPosition] = newFeatureIndex
                                    elseif traversedFeaturePosition == 2 then
                                        if nameOfFeature == 'Field' then
                                            table.insert(tempLinkedFeatures['City-Field'][newFeatureIndex], {x=nestedXIndex, z=nestedZIndex, position=nestedFeatureMapPosition})
                                        elseif nameOfFeature == 'City' then
                                            table.insert(tempLinkedFeatures['City-Field'][newFeatureIndex], {x=nestedXIndex, z=nestedZIndex, position=nestedFeatureMapPosition})
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                for nestedXIndex, gridColumn in pairs(traversedGrid) do
                    for nestedZIndex, tileLocation in pairs(gridColumn) do
                        local nestedTile = getObjectFromGUID(tileGrid[nestedXIndex][nestedZIndex].tile_guid)
                        local nestedTileData = getTileDataForTile(nestedTile)
                        local nestedTileRotation = tileGrid[nestedXIndex][nestedZIndex].rotation
                        for nestedTilePosition, traversedPosition in pairs(tileLocation) do
                            if nestedTilePosition < 13 or nestedTileData.specialFeatures[nestedTilePosition - 12][3] ~= nil then
                                if nestedTilePosition > 4 or getTileFeatureName(nestedTile, nestedTilePosition) == 'Road' or getTileFeatureName(nestedTile, nestedTilePosition) == 'River' then
                                    local nestedFeatureMapPosition = tilePositionToFeatureMapPosition(nestedTilePosition, nestedTileRotation)
                                    --print("traversed x: " .. nestedXIndex .. " z: " .. nestedZIndex .. " featureMapPos: " .. nestedFeatureMapPosition .. " pos: " .. nestedTilePosition)
                                    if traversedFeaturePositions[nestedXIndex] == nil or traversedFeaturePositions[nestedXIndex][nestedZIndex] == nil or traversedFeaturePositions[nestedXIndex][nestedZIndex][nestedTilePosition] == nil or traversedFeaturePositions[nestedXIndex][nestedZIndex][nestedTilePosition] == 2 then
                                        if getTileFeatureName(nestedTile, nestedTilePosition) == 'Field' then
                                            --table.insert(tempLinkedFeatures['City-Field'][newFeatureIndex], {x=nestedXIndex, z=nestedZIndex, position=nestedFeatureMapPosition})
                                        elseif nameOfFeature == 'Field' then
                                            table.insert(tempLinkedFeatures['City-Field'][newFeatureIndex], {x=nestedXIndex, z=nestedZIndex, position=nestedFeatureMapPosition})
                                        else
                                            table.insert(tempLinkedFeatures['Road Intersection'][newFeatureIndex], {x=nestedXIndex, z=nestedZIndex, position=nestedFeatureMapPosition})
                                            --print("added to Road Intersection for: " .. newFeatureIndex)
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    --re-add links
    for featureType, linkedFeatureCategory in pairs(tempLinkedFeatures) do
        for newFeatureIndex, categoryLinkedFeatures in pairs(linkedFeatureCategory) do
            for _, connectedFeatureDetails in ipairs(categoryLinkedFeatures) do
                local connectedFeatureNum = getFeatureNumAt(connectedFeatureDetails.x, connectedFeatureDetails.z, connectedFeatureDetails.position)
                if connectedFeatureNum == nil then
                    allErrorMessage("no feature found at: x: " .. connectedFeatureDetails.x .. " z: " .. connectedFeatureDetails.z .. " pos: " .. connectedFeatureDetails.position)
                else
                    if connectedFeatureNum ~= newFeatureIndex then
                        if linkedFeatures[featureType][newFeatureIndex] == nil then
                            linkedFeatures[featureType][newFeatureIndex] = {}
                        end
                        --print("from location: x: " .. connectedFeatureDetails.x .. " z: " .. connectedFeatureDetails.z .. " pos: " .. connectedFeatureDetails.position)
                        --print("adding " .. featureType .. " link from " .. newFeatureIndex .. " to " .. connectedFeatureNum)
                        linkedFeatures[featureType][newFeatureIndex][connectedFeatureNum] = true
                        if linkedFeatures[featureType][connectedFeatureNum] == nil then
                            linkedFeatures[featureType][connectedFeatureNum] = {}
                        end
                        --print("adding " .. featureType .. " link from " .. connectedFeatureNum .. " to " .. newFeatureIndex)
                        linkedFeatures[featureType][connectedFeatureNum][newFeatureIndex] = true
                    end
                end
            end
        end
    end

    removeFromProximityFeatures = {}
    local specialFeatures = removedTileData.specialFeatures
    if specialFeatures ~= nil then
        --if this tile contains specialFeatures relevant to neighboring tiles, add them to a list (there should only ever be one, but I'm leaving it open to shenanigan fan tiles)
        for _, feature in ipairs(specialFeatures) do
            if feature[1] == 'Vineyard' then
                table.insert(removeFromProximityFeatures, feature[1])
            end
        end
    end

    for _, offset in ipairs(DIAGONAL_DELTA) do
        local neighborX = xIndex + offset.x
        local neighborZ = zIndex + offset.z
        if tileGridOccupied(neighborX, neighborZ) then
            for neighborPositionNum, neighborFeatureNum in pairs(tileGrid[neighborX][neighborZ].featureMap) do
                if table.contains(PROXIMITY_FEATURES, featureList[neighborFeatureNum].nameOfFeature) and neighborPositionNum > 12 then --HACK: Only consider positions over 12 so that abbeys aren't counted multiple times
                    featureList[neighborFeatureNum].numTiles = featureList[neighborFeatureNum].numTiles - 1
                    featureList[neighborFeatureNum].numOpenings = featureList[neighborFeatureNum].numOpenings + 1
                    featureList[neighborFeatureNum].openingCoords[xIndex .. "-" .. zIndex] = true
                    for _, neighborSpecialFeature in ipairs(removeFromProximityFeatures) do
                        for i, specialFeature in ipairs(featureList[neighborFeatureNum].specialFeatures) do
                            if neighborSpecialFeature == specialFeature then
                                table.remove(featureList[neighborFeatureNum].specialFeatures, i)
                                break
                            end
                        end
                    end
                end
            end
        end
    end
    --If validTileLocations is nil, then either AI is disabled or in a bad state. Either way,
    --all AI data will be recalculated at the beginning of the next AI player's turn
    if validTileLocations ~= nil then
        AITileRemoved(xIndex, zIndex, removedTile)
    end

    --We don't know if there is still a tile in play. Set to nil to force a recheck
    tileInPlay = nil
end

--Wrapper method to add a hack for ferry titles
function getLinkedQuadrants(tile)
    if tile ~= nil then
        if tile.guid ~= nil then
            local ferry = ferryGetLinkedQuadrants(tile.guid)
            if ferry ~= nil then
                return ferry
            end
        end
    end
    return getTileDataForTile(tile).linkedQuadrants
end

--Get the feature at the specified position
--Also takes into account features that have no "middle" (ie. fields and cities)
--Will return nil if there is still no feature at the given position (can happen if the feature is on the ignore list or both sides are not linked)
function getFeatureNumAt(xIndex, zIndex, position)
    local featureNum = tileGrid[xIndex][zIndex].featureMap[position]
    if featureNum == nil and position < 5 and tileGrid[xIndex][zIndex].featureMap[(position * 2) + 3] ~= nil and tileGrid[xIndex][zIndex].featureMap[(position * 2) + 3] == tileGrid[xIndex][zIndex].featureMap[(position * 2) + 4] then
        featureNum = tileGrid[xIndex][zIndex].featureMap[(position * 2) + 3]
    end
    return featureNum
end

--Will only work if tilePosition is < 13
--TILE_STANDARD_ROTATION can be used if tilePosition is actually a featureMapPosition TODO: Fix this later
function getConnectingFeatureMapPosition(xIndex, zIndex, tilePosition, tileRotation)
    local connectedFeatureMapPosition
    local connectedX, connectedZ
    if tilePosition < 5 then
        local direction = (3 + tilePosition + tileRotation) % 4 + 1
        local sideDirection = direction
        connectedX = xIndex + SIDE_DELTA[sideDirection].x
        connectedZ = zIndex + SIDE_DELTA[sideDirection].z
        connectedFeatureMapPosition = (3 + tilePosition + tileRotation - TILE_STANDARD_ROTATION + TILE_180_ROTATION) % 4 + 1
    else
        local direction = (3 + tilePosition + (tileRotation * 2)) % 8 + 5
        local sideDirection = math.floor((direction - 3) / 2)
        connectedX = xIndex + SIDE_DELTA[sideDirection].x
        connectedZ = zIndex + SIDE_DELTA[sideDirection].z
        connectedFeatureMapPosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction - (TILE_STANDARD_ROTATION * 2) - 4) % 8 + 5
    end
    return connectedFeatureMapPosition, connectedX, connectedZ
end

function tilePositionToFeatureMapPosition(tilePosition, tileRotation)
    if tilePosition < 5 then
        return (1 + tilePosition + tileRotation) % 4 + 1
    elseif tilePosition < 13 then
        return (tilePosition + (tileRotation * 2) - 1) % 8 + 5
    else
        return tilePosition
    end
end

function featureMapPositionToTilePosition(featureMapPosition, tileRotation)
    if featureMapPosition < 5 then
        return (5 + featureMapPosition - tileRotation) % 4 + 1
    elseif featureMapPosition < 13 then
        return (featureMapPosition - (tileRotation * 2) + 7) % 8 + 5
    else
        return featureMapPosition
    end
end

--This function will completely shift all objects on the table, along with the stored metadata, by the given deltas
function shiftPlayArea(delta_x, delta_z)
    allGameMessage(({"MESSAGE_PLAY_AREA_SHIFTING"}), NEUTRAL_COLOR)
    for _, obj in ipairs(getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()) do
        if obj.getGUID() ~= CONTROL_PANEL_GUID then
            local objPos = obj.getPosition()
            objPos.x = objPos.x + delta_x * TILE_SPACING
            objPos.z = objPos.z + delta_z * TILE_SPACING
            obj.setPosition(objPos)
        end
    end
    local start, last
    if delta_x ~= 0 then
        if delta_x < 0 then
            start = MIN_X
            last = MAX_X
        else
            start = MAX_X
            last = MIN_X
        end
        for x=start, last, -delta_x do
            if tileGrid[x] ~= nil then
                tileGrid[x + delta_x] = tileGrid[x]
                tileGrid[x] = nil
            end
        end
        for x=start, last, -delta_x do
            if validTileLocations ~= nil then
                for openingCoord, _ in pairs(validTileLocations) do
                    local coord = string.split(openingCoord, "-")
                    local oldX = tonumber(coord[1])
                    local oldZ = tonumber(coord[2])
                    if (oldX == x) then
                        validTileLocations[oldX + delta_x .. "-" .. oldZ] = validTileLocations[oldX .. "-" .. oldZ]
                        validTileLocations[oldX .. "-" .. oldZ] = nil
                        tileConnectionOdds[oldX + delta_x .. "-" .. oldZ] = tileConnectionOdds[oldX .. "-" .. oldZ]
                        tileConnectionOdds[oldX .. "-" .. oldZ] = nil
                    end
                end
            end
            for _, feature in pairs(featureList) do
                for openingCoord, _ in pairs(feature.openingCoords) do
                    local coord = string.split(openingCoord, "-")
                    local oldX = tonumber(coord[1])
                    local oldZ = tonumber(coord[2])
                    if (oldX == x) then
                        feature.openingCoords[oldX + delta_x .. "-" .. oldZ] = true
                        feature.openingCoords[oldX .. "-" .. oldZ] = nil
                    end
                end
            end
        end
    end
    if delta_z ~= 0 then
        if delta_z < 0 then
            start = MIN_Z
            last = MAX_Z
        else
            start = MAX_Z
            last = MIN_Z
        end
        for x, _ in pairs(tileGrid) do
            for z=start, last, -delta_z do
                if tileGrid[x][z] ~= nil then
                    tileGrid[x][z + delta_z] = tileGrid[x][z]
                    tileGrid[x][z] = nil
                end
            end
        end
        for z=start, last, -delta_z do
            for openingCoord, _ in pairs(validTileLocations) do
                local coord = string.split(openingCoord, "-")
                local oldX = tonumber(coord[1])
                local oldZ = tonumber(coord[2])
                if (oldZ == z) then
                    validTileLocations[oldX .. "-" .. oldZ + delta_z] = validTileLocations[oldX .. "-" .. oldZ]
                    validTileLocations[oldX .. "-" .. oldZ] = nil
                    tileConnectionOdds[oldX .. "-" .. oldZ + delta_z] = tileConnectionOdds[oldX .. "-" .. oldZ]
                    tileConnectionOdds[oldX .. "-" .. oldZ] = nil
                end
            end
            for _, feature in pairs(featureList) do
                for openingCoord, _ in pairs(feature.openingCoords) do
                    local coord = string.split(openingCoord, "-")
                    local oldX = tonumber(coord[1])
                    local oldZ = tonumber(coord[2])
                    if (oldZ == z) then
                        feature.openingCoords[oldX .. "-" .. oldZ + delta_z] = true
                        feature.openingCoords[oldX .. "-" .. oldZ] = nil
                    end
                end
            end
        end
    end
end
